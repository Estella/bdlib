.TH "StringBuf" 3 "18 Dec 2009" "Version 1.0" "BDLIB" \" -*- nroff -*-
.ad l
.nh
.SH NAME
StringBuf \- Helps the \fBString\fP class with reference counting.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <String.h>\fP
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBReserve\fP (const size_t) const "
.br
.RI "\fIEnsure that the buffer capacity() is >= newSize; else grow/copy into larger buffer. \fP"
.ti -1c
.RI "char * \fBAllocBuf\fP (const size_t bytes) const "
.br
.RI "\fIAllocates a buffer and returns it's address. \fP"
.ti -1c
.RI "void \fBFreeBuf\fP (const char *p) const "
.br
.RI "\fIFree's up the allocated buffer. \fP"
.ti -1c
.RI "bool \fBisShared\fP () const "
.br
.RI "\fIIs this string shared? \fP"
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "size_t \fBlen\fP"
.br
.ti -1c
.RI "size_t \fBsize\fP"
.br
.ti -1c
.RI "char * \fBbuf\fP"
.br
.ti -1c
.RI "uint8_t \fBn\fP"
.br
.ti -1c
.RI "char \fBsbuf\fP [16]"
.br
.in -1c
.SH "Detailed Description"
.PP 
Helps the \fBString\fP class with reference counting. 

\fBTodo\fP
.RS 4
look into something like a string object made of string pointers, and << displays all of the pointed to objects. (this would save copying to construct immuatable concatenated strings, but would only work with the << stream 
.RE
.PP

.PP
Definition at line 56 of file String.h.
.SH "Member Function Documentation"
.PP 
.SS "char* StringBuf::AllocBuf (const size_t bytes) const\fC [inline]\fP"
.PP
Allocates a buffer and returns it's address. 
.PP
\fBParameters:\fP
.RS 4
\fIbytes\fP The number of bytes to allocate. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A new block of memory is allocated. 
.RE
.PP
\fBTodo\fP
.RS 4
Implement mempool here. 
.RE
.PP

.PP
Definition at line 73 of file String.h.
.SS "void StringBuf::FreeBuf (const char * p) const\fC [inline]\fP"
.PP
Free's up the allocated buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIp\fP The buffer to be free'd 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer is deleted. 
.RE
.PP
\fBTodo\fP
.RS 4
Implement mempool here. 
.RE
.PP

.PP
Definition at line 84 of file String.h.
.SS "BDLIB_NS_BEGIN void StringBuf::Reserve (const size_t newSize) const"
.PP
Ensure that the buffer capacity() is >= newSize; else grow/copy into larger buffer. 
.PP
\fBParameters:\fP
.RS 4
\fInewSize\fP A size that we need to Allocate the buffer to. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
newSize is > 0 (assumed as size_t is unsigned) 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer is at least nsize bytes long. 
.PP
If the buffer had to grow, the old data was deep copied into the new buffer and the old deleted. 
.RE
.PP

.PP
Definition at line 47 of file String.cpp.

.SH "Author"
.PP 
Generated automatically by Doxygen for BDLIB from the source code.
