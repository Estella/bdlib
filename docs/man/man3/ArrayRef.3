.TH "ArrayRef" 3 "18 Dec 2009" "Version 1.0" "BDLIB" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ArrayRef \- Helps the \fBString\fP class with reference counting.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <ReferenceCountedArray.h>\fP
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "T * \fBAllocBuf\fP (const size_t bytes) const "
.br
.RI "\fIAllocates a buffer and returns it's address. \fP"
.ti -1c
.RI "\fBArrayRef\fP ()"
.br
.ti -1c
.RI "void \fBFreeBuf\fP (T *p) const "
.br
.RI "\fIFree's up the allocated buffer. \fP"
.ti -1c
.RI "bool \fBisShared\fP () const "
.br
.RI "\fIIs this string shared? \fP"
.ti -1c
.RI "void \fBReserve\fP (const size_t newSize, size_t &offset) const "
.br
.RI "\fIEnsure that the buffer capacity() is >= newSize; else grow/copy into larger buffer. \fP"
.ti -1c
.RI "\fB~ArrayRef\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "T * \fBbuf\fP"
.br
.ti -1c
.RI "size_t \fBlen\fP"
.br
.ti -1c
.RI "uint8_t \fBn\fP"
.br
.ti -1c
.RI "size_t \fBsize\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class T> class ArrayRef< T >"
Helps the \fBString\fP class with reference counting. 

\fBTodo\fP
.RS 4
look into something like a string object made of string pointers, and << displays all of the pointed to objects. (this would save copying to construct immuatable concatenated strings, but would only work with the << stream 
.RE
.PP

.PP
Definition at line 40 of file ReferenceCountedArray.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class T> \fBArrayRef\fP< T >::~\fBArrayRef\fP ()\fC [inline]\fP"
.PP
Definition at line 42 of file ReferenceCountedArray.h.
.SS "template<class T> \fBArrayRef\fP< T >::\fBArrayRef\fP ()\fC [inline]\fP"
.PP
Definition at line 48 of file ReferenceCountedArray.h.
.SH "Member Function Documentation"
.PP 
.SS "template<class T> T* \fBArrayRef\fP< T >::AllocBuf (const size_t bytes) const\fC [inline]\fP"
.PP
Allocates a buffer and returns it's address. 
.PP
\fBParameters:\fP
.RS 4
\fIbytes\fP The number of bytes to allocate. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A new block of memory is allocated. 
.RE
.PP
\fBTodo\fP
.RS 4
Implement mempool here. 
.RE
.PP

.PP
Definition at line 87 of file ReferenceCountedArray.h.
.SS "template<class T> void \fBArrayRef\fP< T >::FreeBuf (T * p) const\fC [inline]\fP"
.PP
Free's up the allocated buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIp\fP The buffer to be free'd 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer is deleted. 
.RE
.PP
\fBTodo\fP
.RS 4
Implement mempool here. 
.RE
.PP

.PP
Definition at line 97 of file ReferenceCountedArray.h.
.SS "template<class T> bool \fBArrayRef\fP< T >::isShared () const\fC [inline]\fP"
.PP
Is this string shared? 
.PP
Definition at line 104 of file ReferenceCountedArray.h.
.SS "template<class T> void \fBArrayRef\fP< T >::Reserve (const size_t newSize, size_t & offset) const\fC [inline]\fP"
.PP
Ensure that the buffer capacity() is >= newSize; else grow/copy into larger buffer. 
.PP
\fBParameters:\fP
.RS 4
\fInewSize\fP A size that we need to Allocate the buffer to. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
newSize is > 0 (assumed as size_t is unsigned) 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer is at least nsize bytes long. 
.PP
If the buffer had to grow, the old data was deep copied into the new buffer and the old deleted. 
.RE
.PP

.PP
Definition at line 56 of file ReferenceCountedArray.h.
.SH "Member Data Documentation"
.PP 
.SS "template<class T> T* \fBArrayRef\fP< T >::\fBbuf\fP\fC [mutable]\fP"
.PP
Definition at line 45 of file ReferenceCountedArray.h.
.SS "template<class T> size_t \fBArrayRef\fP< T >::\fBlen\fP\fC [mutable]\fP"
.PP
Definition at line 42 of file ReferenceCountedArray.h.
.SS "template<class T> uint8_t \fBArrayRef\fP< T >::\fBn\fP\fC [mutable]\fP"
.PP
Definition at line 46 of file ReferenceCountedArray.h.
.SS "template<class T> size_t \fBArrayRef\fP< T >::\fBsize\fP\fC [mutable]\fP"
.PP
Definition at line 44 of file ReferenceCountedArray.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for BDLIB from the source code.
