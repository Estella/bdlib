.TH "ReferenceCountedArray" 3 "18 Dec 2009" "Version 1.0" "BDLIB" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ReferenceCountedArray \- 
.SH SYNOPSIS
.br
.PP
\fC#include <ReferenceCountedArray.h>\fP
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBCref\fP"
.br
.RI "\fISafe element reading and writing. \fP"
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef const \fBvalue_type\fP * \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef const \fBvalue_type\fP & \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef ptrdiff_t \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef \fBvalue_type\fP * \fBpointer\fP"
.br
.ti -1c
.RI "typedef \fBvalue_type\fP & \fBreference\fP"
.br
.ti -1c
.RI "typedef size_t \fBsize_type\fP"
.br
.ti -1c
.RI "typedef T \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBappend\fP (const \fBReferenceCountedArray\fP &rca, int n=-1)"
.br
.RI "\fIAppends given rca to the end of buffer. \fP"
.ti -1c
.RI "void \fBappend\fP (\fBconst_reference\fP item)"
.br
.RI "\fIAppends one item to end of buffer. \fP"
.ti -1c
.RI "\fBvalue_type\fP \fBat\fP (int i) const "
.br
.RI "\fIReturns the character at the given index. \fP"
.ti -1c
.RI "\fBconst_pointer\fP \fBbegin\fP () const "
.br
.ti -1c
.RI "size_t \fBcapacity\fP () const "
.br
.RI "\fIReturns capacity of the \fBString\fP object. \fP"
.ti -1c
.RI "virtual void \fBclear\fP ()"
.br
.RI "\fIClear contents of \fBString\fP and set length to 0. \fP"
.ti -1c
.RI "\fBconst_pointer\fP \fBdata\fP () const "
.br
.RI "\fIData accessor. \fP"
.ti -1c
.RI "\fBconst_pointer\fP \fBend\fP () const "
.br
.ti -1c
.RI "size_t \fBfind\fP (\fBconst_reference\fP item) const "
.br
.ti -1c
.RI "virtual size_t \fBhash\fP () const =0"
.br
.ti -1c
.RI "bool \fBhasIndex\fP (int i) const "
.br
.RI "\fIChecks if the buffer has the given index or not. \fP"
.ti -1c
.RI "void \fBinsert\fP (int k, \fBconst_reference\fP item)"
.br
.RI "\fIInsert an item at the given index. \fP"
.ti -1c
.RI "void \fBinsert\fP (int k, const \fBReferenceCountedArray\fP &rca, int n=-1)"
.br
.RI "\fIInserts a \fBReferenceCountedArray\fP object into our buffer. \fP"
.ti -1c
.RI "bool \fBisEmpty\fP () const "
.br
.RI "\fICheck whether the string is 'empty'. \fP"
.ti -1c
.RI "bool \fBisShared\fP () const "
.br
.ti -1c
.RI "size_t \fBlength\fP () const "
.br
.RI "\fIReturns length of the string. \fP"
.ti -1c
.RI "bool \fBoperator!\fP () const "
.br
.ti -1c
.RI "const \fBReferenceCountedArray\fP & \fBoperator=\fP (\fBconst_reference\fP item)"
.br
.RI "\fISets our buffer to the given item. \fP"
.ti -1c
.RI "const \fBReferenceCountedArray\fP & \fBoperator=\fP (const \fBReferenceCountedArray\fP &rca)"
.br
.RI "\fISets our Reference to the given \fBString\fP reference. \fP"
.ti -1c
.RI "\fBCref\fP \fBoperator[]\fP (int i)"
.br
.RI "\fIReturns 'Cref' class for safe (cow) writing into \fBString\fP. \fP"
.ti -1c
.RI "\fBvalue_type\fP \fBoperator[]\fP (int i) const "
.br
.RI "\fISafe element access operator. \fP"
.ti -1c
.RI "size_t \fBrcount\fP () const "
.br
.ti -1c
.RI "\fBvalue_type\fP \fBread\fP (int i) const "
.br
.ti -1c
.RI "\fBReferenceCountedArray\fP (const size_t newSize)"
.br
.RI "\fICreate an empty \fBString\fP container with at least the specified bytes in size. \fP"
.ti -1c
.RI "\fBReferenceCountedArray\fP (const \fBReferenceCountedArray\fP &rca)"
.br
.ti -1c
.RI "\fBReferenceCountedArray\fP ()"
.br
.ti -1c
.RI "void \fBreplace\fP (int k, const \fBReferenceCountedArray\fP &rca, int n=-1)"
.br
.RI "\fIReplaces n elements in our buffer at index k with the given \fBReferenceCountedArray\fP object. \fP"
.ti -1c
.RI "void \fBreplace\fP (int k, \fBconst_reference\fP item)"
.br
.RI "\fIReplace the given index with the given item. \fP"
.ti -1c
.RI "virtual void \fBReserve\fP (const size_t newSize) const "
.br
.ti -1c
.RI "size_t \fBsize\fP () const "
.br
.ti -1c
.RI "void \fBslice\fP (int start, int len)"
.br
.RI "\fIReturn a new array from a subarray. \fP"
.ti -1c
.RI "void \fBwrite\fP (int i, \fBvalue_type\fP item)"
.br
.ti -1c
.RI "virtual \fB~ReferenceCountedArray\fP ()"
.br
.RI "\fI\fBArray\fP Destructor. \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBAboutToModify\fP (size_t n) const "
.br
.ti -1c
.RI "void \fBaddLength\fP (size_t diff) const "
.br
.ti -1c
.RI "\fBpointer\fP \fBBuf\fP (int i=0) const "
.br
.RI "\fIMutable Ref->buf+offset reference for use internally. \fP"
.ti -1c
.RI "\fBconst_pointer\fP \fBconstBuf\fP (int i=0) const "
.br
.RI "\fIRef->buf reference for use internally. \fP"
.ti -1c
.RI "void \fBgetOwnCopy\fP () const "
.br
.ti -1c
.RI "void \fBsetLength\fP (size_t newLen) const "
.br
.RI "\fISet the lengths to the specified length. \fP"
.ti -1c
.RI "void \fBsubLength\fP (size_t diff) const "
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "size_t \fBoffset\fP"
.br
.ti -1c
.RI "size_t \fBsublen\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class T> class ReferenceCountedArray< T >"

.PP
Definition at line 164 of file ReferenceCountedArray.h.
.SH "Member Typedef Documentation"
.PP 
.SS "template<class T> typedef const \fBvalue_type\fP* \fBReferenceCountedArray\fP< T >::\fBconst_pointer\fP"
.PP
Reimplemented in \fBArray< T >\fP.
.PP
Definition at line 171 of file ReferenceCountedArray.h.
.SS "template<class T> typedef const \fBvalue_type\fP& \fBReferenceCountedArray\fP< T >::\fBconst_reference\fP"
.PP
Reimplemented in \fBArray< T >\fP.
.PP
Definition at line 173 of file ReferenceCountedArray.h.
.SS "template<class T> typedef ptrdiff_t \fBReferenceCountedArray\fP< T >::\fBdifference_type\fP"
.PP
Reimplemented in \fBArray< T >\fP.
.PP
Definition at line 169 of file ReferenceCountedArray.h.
.SS "template<class T> typedef \fBvalue_type\fP* \fBReferenceCountedArray\fP< T >::\fBpointer\fP"
.PP
Reimplemented in \fBArray< T >\fP.
.PP
Definition at line 170 of file ReferenceCountedArray.h.
.SS "template<class T> typedef \fBvalue_type\fP& \fBReferenceCountedArray\fP< T >::\fBreference\fP"
.PP
Reimplemented in \fBArray< T >\fP.
.PP
Definition at line 172 of file ReferenceCountedArray.h.
.SS "template<class T> typedef size_t \fBReferenceCountedArray\fP< T >::\fBsize_type\fP"
.PP
Reimplemented in \fBArray< T >\fP.
.PP
Definition at line 168 of file ReferenceCountedArray.h.
.SS "template<class T> typedef T \fBReferenceCountedArray\fP< T >::\fBvalue_type\fP"
.PP
Reimplemented in \fBArray< T >\fP.
.PP
Definition at line 166 of file ReferenceCountedArray.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class T> \fBReferenceCountedArray\fP< T >::\fBReferenceCountedArray\fP ()\fC [inline]\fP"
.PP
Definition at line 306 of file ReferenceCountedArray.h.
.SS "template<class T> \fBReferenceCountedArray\fP< T >::\fBReferenceCountedArray\fP (const \fBReferenceCountedArray\fP< T > & rca)\fC [inline]\fP"
.PP
Definition at line 307 of file ReferenceCountedArray.h.
.SS "template<class T> \fBReferenceCountedArray\fP< T >::\fBReferenceCountedArray\fP (const size_t newSize)\fC [inline, explicit]\fP"
.PP
Create an empty \fBString\fP container with at least the specified bytes in size. 
.PP
\fBParameters:\fP
.RS 4
\fInewSize\fP Reserve at least this many bytes for this \fBString\fP. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
This string's memory will also never be shrunk. 
.PP
A buffer has been created.
.RE
.PP
The idea behind this is that if a specific size was asked for, the buffer is like a char buf[N]; 
.PP
Definition at line 317 of file ReferenceCountedArray.h.
.SS "template<class T> virtual \fBReferenceCountedArray\fP< T >::~\fBReferenceCountedArray\fP ()\fC [inline, virtual]\fP"
.PP
\fBArray\fP Destructor. 
.PP
\fBPostcondition:\fP
.RS 4
If the Array's Reference is not shared, it is free'd. 
.PP
If the Array's Reference IS shared, it is decremented and detached. 
.RE
.PP

.PP
Definition at line 327 of file ReferenceCountedArray.h.
.SH "Member Function Documentation"
.PP 
.SS "template<class T> void \fBReferenceCountedArray\fP< T >::AboutToModify (size_t n) const\fC [inline, protected]\fP"
.PP
Definition at line 297 of file ReferenceCountedArray.h.
.SS "template<class T> void \fBReferenceCountedArray\fP< T >::addLength (size_t diff) const\fC [inline, protected]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBsetLength()\fP 
.RE
.PP

.PP
Definition at line 207 of file ReferenceCountedArray.h.
.SS "template<class T> void \fBReferenceCountedArray\fP< T >::append (const \fBReferenceCountedArray\fP< T > & rca, int n = \fC-1\fP)\fC [inline]\fP"
.PP
Appends given rca to the end of buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIrca\fP The rca to be appended. 
.br
\fIn\fP How many characters to copy from the \fBReferenceCountedArray\fP object. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer is allocated. This is the same as inserting the rca at the end of the buffer. 
.RE
.PP

.PP
Definition at line 570 of file ReferenceCountedArray.h.
.SS "template<class T> void \fBReferenceCountedArray\fP< T >::append (\fBconst_reference\fP item)\fC [inline]\fP"
.PP
Appends one item to end of buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIitem\fP The item to be appended. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer is allocated. 
.PP
The item is appended at the end of the buffer. This is the same as inserting the item at the end of the buffer. 
.RE
.PP

.PP
Definition at line 562 of file ReferenceCountedArray.h.
.SS "template<class T> \fBvalue_type\fP \fBReferenceCountedArray\fP< T >::at (int i) const\fC [inline]\fP"
.PP
Returns the character at the given index. 
.PP
\fBReturns:\fP
.RS 4
The character at the given index. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Index to return. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
The index must exist. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator[]()\fP 
.RE
.PP
\fBTodo\fP
.RS 4
Perhaps this should throw an exception if out of range? 
.RE
.PP

.PP
Definition at line 520 of file ReferenceCountedArray.h.
.SS "template<class T> \fBconst_pointer\fP \fBReferenceCountedArray\fP< T >::begin () const\fC [inline]\fP"
.PP
Definition at line 416 of file ReferenceCountedArray.h.
.SS "template<class T> \fBpointer\fP \fBReferenceCountedArray\fP< T >::Buf (int i = \fC0\fP) const\fC [inline, protected]\fP"
.PP
Mutable Ref->buf+offset reference for use internally. 
.PP
Mutable Ref->buf reference for use internally 
.PP
Definition at line 222 of file ReferenceCountedArray.h.
.SS "template<class T> size_t \fBReferenceCountedArray\fP< T >::capacity () const\fC [inline]\fP"
.PP
Returns capacity of the \fBString\fP object. 
.PP
\fBReturns:\fP
.RS 4
Capacity of the \fBString\fP object. 
.RE
.PP

.PP
Definition at line 385 of file ReferenceCountedArray.h.
.SS "template<class T> virtual void \fBReferenceCountedArray\fP< T >::clear ()\fC [inline, virtual]\fP"
.PP
Clear contents of \fBString\fP and set length to 0. 
.PP
Definition at line 379 of file ReferenceCountedArray.h.
.SS "template<class T> \fBconst_pointer\fP \fBReferenceCountedArray\fP< T >::constBuf (int i = \fC0\fP) const\fC [inline, protected]\fP"
.PP
Ref->buf reference for use internally. 
.PP
Definition at line 227 of file ReferenceCountedArray.h.
.SS "template<class T> \fBconst_pointer\fP \fBReferenceCountedArray\fP< T >::data () const\fC [inline]\fP"
.PP
Data accessor. 
.PP
\fBReturns:\fP
.RS 4
Pointer to array of characters (not necesarily null-terminated). 
.RE
.PP

.PP
Definition at line 415 of file ReferenceCountedArray.h.
.SS "template<class T> \fBconst_pointer\fP \fBReferenceCountedArray\fP< T >::end () const\fC [inline]\fP"
.PP
Definition at line 417 of file ReferenceCountedArray.h.
.SS "template<class T> size_t \fBReferenceCountedArray\fP< T >::find (\fBconst_reference\fP item) const\fC [inline]\fP"
.PP
Definition at line 425 of file ReferenceCountedArray.h.
.SS "template<class T> void \fBReferenceCountedArray\fP< T >::getOwnCopy () const\fC [inline, protected]\fP"
.PP
Definition at line 296 of file ReferenceCountedArray.h.
.SS "template<class T> virtual size_t \fBReferenceCountedArray\fP< T >::hash () const\fC [pure virtual]\fP"
.PP
Implemented in \fBArray< T >\fP, and \fBString\fP.
.SS "template<class T> bool \fBReferenceCountedArray\fP< T >::hasIndex (int i) const\fC [inline]\fP"
.PP
Checks if the buffer has the given index or not. 
.PP
\fBReturns:\fP
.RS 4
Boolean true/false as to whether or not index exists. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Index to check. 
.RE
.PP

.PP
Definition at line 438 of file ReferenceCountedArray.h.
.SS "template<class T> void \fBReferenceCountedArray\fP< T >::insert (int k, \fBconst_reference\fP item)\fC [inline]\fP"
.PP
Insert an item at the given index. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to insert at. 
.br
\fIitem\fP The item to be inserted. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A buffer is allocated. 
.PP
If the old buffer was too small, it is enlarged. 
.PP
The item is inserted at the given index. 
.RE
.PP

.PP
Definition at line 609 of file ReferenceCountedArray.h.
.SS "template<class T> void \fBReferenceCountedArray\fP< T >::insert (int k, const \fBReferenceCountedArray\fP< T > & rca, int n = \fC-1\fP)\fC [inline]\fP"
.PP
Inserts a \fBReferenceCountedArray\fP object into our buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to insert at. 
.br
\fIrca\fP The rca to insert. 
.br
\fIn\fP The length to insert. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer contains n items from rca inserted at index k. 
.RE
.PP

.PP
Definition at line 580 of file ReferenceCountedArray.h.
.SS "template<class T> bool \fBReferenceCountedArray\fP< T >::isEmpty () const\fC [inline]\fP"
.PP
Check whether the string is 'empty'. 
.PP
\fBReturns:\fP
.RS 4
True if empty, false if non-empty 
.RE
.PP

.PP
Definition at line 403 of file ReferenceCountedArray.h.
.SS "template<class T> bool \fBReferenceCountedArray\fP< T >::isShared () const\fC [inline]\fP"
.PP
\fBReturns:\fP
.RS 4
True if this object is shared; false if not. 
.RE
.PP

.PP
Definition at line 367 of file ReferenceCountedArray.h.
.SS "template<class T> size_t \fBReferenceCountedArray\fP< T >::length () const\fC [inline]\fP"
.PP
Returns length of the string. 
.PP
\fBReturns:\fP
.RS 4
Length of the string. 
.RE
.PP

.PP
Definition at line 393 of file ReferenceCountedArray.h.
.SS "template<class T> bool \fBReferenceCountedArray\fP< T >::operator! () const\fC [inline]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBisEmpty()\fP This is for: if (!string) Having if(string) conflicts with another operator 
.RE
.PP

.PP
Definition at line 409 of file ReferenceCountedArray.h.
.SS "template<class T> const \fBReferenceCountedArray\fP& \fBReferenceCountedArray\fP< T >::operator= (\fBconst_reference\fP item)\fC [inline]\fP"
.PP
Sets our buffer to the given item. 
.PP
\fBParameters:\fP
.RS 4
\fIitem\fP The item to set our buffer to. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The old buffer (if we had one) is free'd. 
.PP
A sufficiently sized new buffer is made with the item within. 
.RE
.PP
\fBReturns:\fP
.RS 4
The new array object. 
.RE
.PP

.PP
Definition at line 354 of file ReferenceCountedArray.h.
.SS "template<class T> const \fBReferenceCountedArray\fP& \fBReferenceCountedArray\fP< T >::operator= (const \fBReferenceCountedArray\fP< T > & rca)\fC [inline]\fP"
.PP
Sets our Reference to the given \fBString\fP reference. 
.PP
\fBParameters:\fP
.RS 4
\fIrca\fP The \fBString\fP object to reference. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The old buffer (if we had one) is free'd. 
.PP
Our Reference now points to the given \fBString\fP. 
.PP
Our old rca object has been deleted (disconnected). 
.RE
.PP
\fBReturns:\fP
.RS 4
The new rca object. This handles self-assignment just fine, checking for it explicitly would be ineffecient for most cases. 
.RE
.PP

.PP
Definition at line 338 of file ReferenceCountedArray.h.
.SS "template<class T> \fBCref\fP \fBReferenceCountedArray\fP< T >::operator[] (int i)\fC [inline]\fP"
.PP
Returns 'Cref' class for safe (cow) writing into \fBString\fP. 
.PP
\fBSee also:\fP
.RS 4
\fBCref\fP 
.RE
.PP

.PP
Definition at line 510 of file ReferenceCountedArray.h.
.SS "template<class T> \fBvalue_type\fP \fBReferenceCountedArray\fP< T >::operator[] (int i) const\fC [inline]\fP"
.PP
Safe element access operator. 
.PP
\fBTodo\fP
.RS 4
This is only called on a (const) \fBString\fP, but should for a \fBString\fP as well. 
.RE
.PP

.PP
Definition at line 460 of file ReferenceCountedArray.h.
.SS "template<class T> size_t \fBReferenceCountedArray\fP< T >::rcount () const\fC [inline]\fP"
.PP
Definition at line 363 of file ReferenceCountedArray.h.
.SS "template<class T> \fBvalue_type\fP \fBReferenceCountedArray\fP< T >::read (int i) const\fC [inline]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBat()\fP Unlinke \fBat()\fP this is unchecked. 
.RE
.PP

.PP
Definition at line 449 of file ReferenceCountedArray.h.
.SS "template<class T> void \fBReferenceCountedArray\fP< T >::replace (int k, const \fBReferenceCountedArray\fP< T > & rca, int n = \fC-1\fP)\fC [inline]\fP"
.PP
Replaces n elements in our buffer at index k with the given \fBReferenceCountedArray\fP object. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to replace at. 
.br
\fIrca\fP The \fBReferenceCountedArray\fP object to replace with. 
.br
\fIn\fP The number of characters to use for the replace. 
.RE
.PP

.PP
Definition at line 639 of file ReferenceCountedArray.h.
.SS "template<class T> void \fBReferenceCountedArray\fP< T >::replace (int k, \fBconst_reference\fP item)\fC [inline]\fP"
.PP
Replace the given index with the given item. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to replace. 
.br
\fIitem\fP The item to replace with. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The given index has been replaced. 
.PP
COW is done if needed. 
.RE
.PP

.PP
Definition at line 626 of file ReferenceCountedArray.h.
.SS "template<class T> virtual void \fBReferenceCountedArray\fP< T >::Reserve (const size_t newSize) const\fC [inline, virtual]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBArrayRef::Reserve()\fP 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The \fBString\fP will also never shrink after this. 
.RE
.PP

.PP
Definition at line 374 of file ReferenceCountedArray.h.
.SS "template<class T> void \fBReferenceCountedArray\fP< T >::setLength (size_t newLen) const\fC [inline, protected]\fP"
.PP
Set the lengths to the specified length. 
.PP
\fBParameters:\fP
.RS 4
\fInewLen\fP the new length to set to 
.RE
.PP

.PP
Definition at line 202 of file ReferenceCountedArray.h.
.SS "template<class T> size_t \fBReferenceCountedArray\fP< T >::size () const\fC [inline]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBlength()\fP 
.RE
.PP

.PP
Definition at line 397 of file ReferenceCountedArray.h.
.SS "template<class T> void \fBReferenceCountedArray\fP< T >::slice (int start, int len)\fC [inline]\fP"
.PP
Return a new array from a subarray. 
.PP
\fBReturns:\fP
.RS 4
a new \fBReferenceCountedArray\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIstart\fP The offset to begin the subarray from (indexed from 0) 
.br
\fIlen\fP The length of the subarray to return The returned slice is a reference to the original array until modified. 
.RE
.PP

.PP
Definition at line 529 of file ReferenceCountedArray.h.
.SS "template<class T> void \fBReferenceCountedArray\fP< T >::subLength (size_t diff) const\fC [inline, protected]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBsetLength()\fP 
.RE
.PP

.PP
Definition at line 212 of file ReferenceCountedArray.h.
.SS "template<class T> void \fBReferenceCountedArray\fP< T >::write (int i, \fBvalue_type\fP item)\fC [inline]\fP"
.PP
Definition at line 451 of file ReferenceCountedArray.h.
.SH "Member Data Documentation"
.PP 
.SS "template<class T> size_t \fBReferenceCountedArray\fP< T >::\fBoffset\fP\fC [mutable, protected]\fP"
.PP
This is for subarrays: so we know where the subarray starts. 
.PP
Definition at line 238 of file ReferenceCountedArray.h.
.SS "template<class T> size_t \fBReferenceCountedArray\fP< T >::\fBsublen\fP\fC [mutable, protected]\fP"
.PP
This is for subarrays: so we know where the subarray ends. 
.PP
Definition at line 242 of file ReferenceCountedArray.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for BDLIB from the source code.
