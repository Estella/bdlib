.TH "String" 3 "18 Dec 2009" "Version 1.0" "BDLIB" \" -*- nroff -*-
.ad l
.nh
.SH NAME
String \- Provides custom string class for easy and optimized string manipulation.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <String.h>\fP
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBCref\fP"
.br
.RI "\fISafe element reading and writing. \fP"
.ti -1c
.RI "class \fBSubString\fP"
.br
.RI "\fISafe substring reading and writing. \fP"
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "int \fBrcount\fP () const "
.br
.ti -1c
.RI "\fBString\fP (const \fBString\fP &string)"
.br
.ti -1c
.RI "\fBString\fP (const char *cstring)"
.br
.RI "\fICreate a \fBString\fP from a given cstring. \fP"
.ti -1c
.RI "\fBString\fP (const char *cstring, size_t slen)"
.br
.RI "\fICreate a \fBString\fP from a given cstring with the given strlen. \fP"
.ti -1c
.RI "\fBString\fP (const char ch)"
.br
.RI "\fICreate a \fBString\fP from a given character. \fP"
.ti -1c
.RI "\fBString\fP (const int newSize)"
.br
.RI "\fICreate an empty \fBString\fP container with at least the specified bytes in size. \fP"
.ti -1c
.RI "virtual \fB~String\fP ()"
.br
.RI "\fI\fBString\fP Destructor. \fP"
.ti -1c
.RI "const char * \fBbegin\fP () const "
.br
.ti -1c
.RI "const char * \fBend\fP () const "
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.RI "\fIClear contents of \fBString\fP and set length to 0. \fP"
.ti -1c
.RI "size_t \fBlength\fP () const "
.br
.RI "\fIReturns length of the string. \fP"
.ti -1c
.RI "size_t \fBcapacity\fP () const "
.br
.RI "\fIReturns capacity of the \fBString\fP object. \fP"
.ti -1c
.RI "bool \fBisEmpty\fP () const "
.br
.RI "\fICheck whether the string is 'empty'. \fP"
.ti -1c
.RI "bool \fBoperator!\fP () const "
.br
.ti -1c
.RI "const char * \fBc_str\fP () const "
.br
.RI "\fICstring accessor. \fP"
.ti -1c
.RI "const char * \fBoperator*\fP () const "
.br
.ti -1c
.RI "\fBString\fP \fBoperator*\fP (int) const "
.br
.RI "\fIThis is a cast operator to const char* This would be used in this situation: \fBString\fP string('blah'); const char* cstring = (const char*) string;. \fP"
.ti -1c
.RI "const char * \fBdata\fP () const "
.br
.RI "\fIData accessor. \fP"
.ti -1c
.RI "bool \fBhasIndex\fP (int i) const "
.br
.RI "\fIChecks if the buffer has the given index or not. \fP"
.ti -1c
.RI "char \fBread\fP (int i) const "
.br
.ti -1c
.RI "void \fBwrite\fP (int i, char c)"
.br
.ti -1c
.RI "char \fBoperator[]\fP (int i) const "
.br
.RI "\fISafe element access operator. \fP"
.ti -1c
.RI "Cref \fBoperator[]\fP (int i)"
.br
.RI "\fIReturns 'Cref' class for safe (cow) writing into \fBString\fP. \fP"
.ti -1c
.RI "char \fBcharAt\fP (int i) const "
.br
.RI "\fIReturns the character at the given index. \fP"
.ti -1c
.RI "\fBString\fP \fBsubstring\fP (int, int) const "
.br
.RI "\fIReturn a new string from a substring. \fP"
.ti -1c
.RI "SubString \fBoperator()\fP (int start, int len)"
.br
.RI "\fIReturns a 'SubString' class for safe (cow) writing into \fBString\fP. \fP"
.ti -1c
.RI "\fBString\fP \fBoperator()\fP (int start, int len) const "
.br
.RI "\fIReturns a const substring. \fP"
.ti -1c
.RI "size_t \fBhash\fP () const "
.br
.RI "\fIDJB's hash function. \fP"
.ti -1c
.RI "int \fBcompare\fP (const \fBString\fP &string) const "
.br
.RI "\fICompare our \fBString\fP object with another \fBString\fP object. \fP"
.ti -1c
.RI "int \fBcompare\fP (const \fBString\fP &, size_t) const "
.br
.RI "\fICompare our \fBString\fP object with another \fBString\fP object, but only n characters. \fP"
.ti -1c
.RI "void \fBappend\fP (const char ch)"
.br
.RI "\fIAppends one character to end of buffer. \fP"
.ti -1c
.RI "void \fBappend\fP (const char *string, int n=-1)"
.br
.RI "\fIAppends given cstring to end of buffer. \fP"
.ti -1c
.RI "void \fBappend\fP (const \fBString\fP &string, int n=-1)"
.br
.RI "\fIAppends given string to the end of buffer. \fP"
.ti -1c
.RI "void \fBinsert\fP (int, const char)"
.br
.RI "\fIInsert a character at the given index. \fP"
.ti -1c
.RI "void \fBinsert\fP (int, const char *, int=-1)"
.br
.RI "\fIInsert a cstring at the given index. \fP"
.ti -1c
.RI "void \fBinsert\fP (int, const \fBString\fP &, int=-1)"
.br
.RI "\fIInserts a \fBString\fP object into our buffer. \fP"
.ti -1c
.RI "void \fBreplace\fP (int, const char)"
.br
.RI "\fIReplace the given index with the given character. \fP"
.ti -1c
.RI "void \fBreplace\fP (int, const char *, int=-1)"
.br
.RI "\fIReplaces the given index with the given cstring up to the given amount of characters. \fP"
.ti -1c
.RI "void \fBreplace\fP (int, const \fBString\fP &, int=-1)"
.br
.RI "\fIReplaces n characters in our buffer at index k with the given \fBString\fP object. \fP"
.ti -1c
.RI "virtual void \fBReserve\fP (const size_t newSize) const "
.br
.ti -1c
.RI "virtual void \fBprintf\fP (const char *,...)"
.br
.ti -1c
.RI "\fBString\fP & \fBoperator+=\fP (const char)"
.br
.ti -1c
.RI "\fBString\fP & \fBoperator+=\fP (const char *)"
.br
.ti -1c
.RI "\fBString\fP & \fBoperator+=\fP (const \fBString\fP &)"
.br
.ti -1c
.RI "\fBString\fP & \fBoperator+=\fP (int)"
.br
.ti -1c
.RI "\fBString\fP & \fBoperator-=\fP (int)"
.br
.ti -1c
.RI "const \fBString\fP & \fBoperator++\fP ()"
.br
.ti -1c
.RI "const \fBString\fP \fBoperator++\fP (int)"
.br
.ti -1c
.RI "const \fBString\fP & \fBoperator--\fP ()"
.br
.ti -1c
.RI "const \fBString\fP \fBoperator--\fP (int)"
.br
.ti -1c
.RI "virtual const \fBString\fP & \fBoperator=\fP (const char)"
.br
.RI "\fISets our buffer to the given character. \fP"
.ti -1c
.RI "virtual const \fBString\fP & \fBoperator=\fP (const char *)"
.br
.RI "\fISets our buffer to the given string. \fP"
.ti -1c
.RI "const \fBString\fP & \fBoperator=\fP (const \fBString\fP &)"
.br
.RI "\fISets our Reference to the given \fBString\fP reference. \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBCheckDeallocRef\fP ()"
.br
.RI "\fIFree up our reference if we have the last one. \fP"
.ti -1c
.RI "void \fBDetach\fP ()"
.br
.RI "\fIDetach from the reference This is called when the old buffer is no longer needed for this \fBString\fP. ie, \fBoperator=()\fP was called. \fP"
.ti -1c
.RI "void \fBCOW\fP (size_t) const "
.br
.RI "\fIEnsure that our internal buffer is unshared. \fP"
.ti -1c
.RI "void \fBAboutToModify\fP (size_t n) const "
.br
.ti -1c
.RI "void \fBgetOwnCopy\fP () const "
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBStringBuf\fP * \fBRef\fP"
.br
.RI "\fIThe string reference for reference counting This is mutable so that Ref->n can be modified, which really is mutable. \fP"
.ti -1c
.RI "size_t \fBoffset\fP"
.br
.ti -1c
.RI "size_t \fBsublen\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "\fBString\fP \fBoperator+\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.RI "\fIConcatenates two string objects together. \fP"
.ti -1c
.RI "bool \fBoperator==\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "bool \fBoperator>\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &, const \fBString\fP &)"
.br
.ti -1c
.RI "std::ostream & \fBoperator>>\fP (std::ostream &, const \fBString\fP &)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Provides custom string class for easy and optimized string manipulation. 

\fBTodo\fP
.RS 4
compute hash on insert, then use to compare instead of strcmp 
.PP
an updating hash as the copy is done. 
.RE
.PP

.PP
Definition at line 104 of file String.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "String::String (const char * cstring)\fC [inline]\fP"
.PP
Create a \fBString\fP from a given cstring. 
.PP
\fBParameters:\fP
.RS 4
\fIcstring\fP The null-terminated character array to create the object from. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A \fBStringBuf\fP has been initialized. 
.PP
The buffer has been filled with the string. 
.RE
.PP
\fBTest\fP
.RS 4
\fBString\fP test('Some string'); 
.RE
.PP

.PP
Definition at line 321 of file String.h.
.SS "String::String (const char * cstring, size_t slen)\fC [inline]\fP"
.PP
Create a \fBString\fP from a given cstring with the given strlen. 
.PP
\fBParameters:\fP
.RS 4
\fIcstring\fP The null-terminated character array to create the object from. 
.br
\fIslen\fP The length of the given string to use. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
len > 0 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A \fBStringBuf\fP has been initialized. 
.PP
The buffer has been filled with the string (up to len characters). 
.RE
.PP
\fBTest\fP
.RS 4
\fBString\fP test('Some string'); 
.RE
.PP

.PP
Definition at line 332 of file String.h.
.SS "String::String (const char ch)\fC [inline]\fP"
.PP
Create a \fBString\fP from a given character. 
.PP
\fBParameters:\fP
.RS 4
\fIch\fP The character to create the string from. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A stringBuf has been initialized. 
.PP
The buffer has been filled with the caracter. 
.RE
.PP
\fBTest\fP
.RS 4
\fBString\fP test('a'); 
.RE
.PP

.PP
Definition at line 341 of file String.h.
.SS "String::String (const int newSize)\fC [inline, explicit]\fP"
.PP
Create an empty \fBString\fP container with at least the specified bytes in size. 
.PP
\fBParameters:\fP
.RS 4
\fInewSize\fP Reserve at least this many bytes for this \fBString\fP. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
This string's memory will also never be shrunk. 
.PP
A buffer has been created.
.RE
.PP
The idea behind this is that if a specific size was asked for, the buffer is like a char buf[N]; 
.PP
Definition at line 352 of file String.h.
.SS "virtual String::~String ()\fC [inline, virtual]\fP"
.PP
\fBString\fP Destructor. 
.PP
\fBPostcondition:\fP
.RS 4
If the String's Reference is not shared, it is free'd. 
.PP
If the String's Reference IS shared, it is decremented and detached. 
.RE
.PP

.PP
Definition at line 362 of file String.h.
.SH "Member Function Documentation"
.PP 
.SS "void String::append (const \fBString\fP & string, int n = \fC-1\fP)\fC [inline]\fP"
.PP
Appends given string to the end of buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP The string to be appended. 
.br
\fIn\fP How many characters to copy from the \fBString\fP object. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer is allocated. This is the same as inserting the string at the end of the buffer. 
.RE
.PP

.PP
Definition at line 533 of file String.h.
.SS "void String::append (const char * string, int n = \fC-1\fP)\fC [inline]\fP"
.PP
Appends given cstring to end of buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP The cstring to be appended. 
.br
\fIn\fP How many characters to copy from the string. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer is allocated. This is the same as inserting the string at the end of the buffer. 
.RE
.PP

.PP
Definition at line 524 of file String.h.
.SS "void String::append (const char ch)\fC [inline]\fP"
.PP
Appends one character to end of buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIch\fP The character to be appended. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer is allocated. 
.PP
The character is appended at the end of the buffer. This is the same as inserting the character at the end of the buffer. 
.RE
.PP

.PP
Definition at line 515 of file String.h.
.SS "const char* String::c_str () const\fC [inline]\fP"
.PP
Cstring accessor. 
.PP
\fBReturns:\fP
.RS 4
A null-terminated character array (cstring). 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer size is (possibly) incremented by 1 for the '' character. 
.PP
There is a '' at the end of the buffer. 
.PP
The actual \fBString\fP size is unchanged. 
.RE
.PP

.PP
Definition at line 405 of file String.h.
.SS "size_t String::capacity () const\fC [inline]\fP"
.PP
Returns capacity of the \fBString\fP object. 
.PP
\fBReturns:\fP
.RS 4
Capacity of the \fBString\fP object. 
.RE
.PP

.PP
Definition at line 384 of file String.h.
.SS "char String::charAt (int i) const\fC [inline]\fP"
.PP
Returns the character at the given index. 
.PP
\fBReturns:\fP
.RS 4
The character at the given index. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Index to return. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
The index must exist. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator[]()\fP 
.RE
.PP
\fBTodo\fP
.RS 4
Perhaps this should throw an exception if out of range? 
.RE
.PP

.PP
Definition at line 481 of file String.h.
.SS "void String::CheckDeallocRef ()\fC [inline, protected]\fP"
.PP
Free up our reference if we have the last one. 
.PP
\fBPostcondition:\fP
.RS 4
The reference counter is decremented. 
.PP
If this was the last Reference, it is free'd This is only called in \fB~String()\fP and operator=(String&). It checks whether of not this \fBString\fP was the last reference to the buffer, and if it was, it removes it. 
.RE
.PP

.PP
Definition at line 280 of file String.h.
.SS "int String::compare (const \fBString\fP & str, size_t n) const"
.PP
Compare our \fBString\fP object with another \fBString\fP object, but only n characters. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP The \fBString\fP object to compare to. 
.br
\fIn\fP The number of characters to compare. 
.RE
.PP
\fBReturns:\fP
.RS 4
an integer less than, equal to, or greater than zero if our buffer is found, respectively, to be less than, to match, or be greater than str. 
.RE
.PP

.PP
Definition at line 93 of file String.cpp.
.SS "int String::compare (const \fBString\fP & string) const\fC [inline]\fP"
.PP
Compare our \fBString\fP object with another \fBString\fP object. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP The \fBString\fP object to compare to 
.RE
.PP
\fBReturns:\fP
.RS 4
an integer less than, equal to, or greater than zero if our buffer is found, respectively, to be less than, to match, or be greater than str. 
.RE
.PP

.PP
Definition at line 503 of file String.h.
.SS "void String::COW (size_t n) const\fC [protected]\fP"
.PP
Ensure that our internal buffer is unshared. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP Create/Grow the buffer to this size. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
n is > 0; this is assumed due to size_t being unsigned though. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The internal buffer/data is unshared 
.PP
The buffer is at least size n. 
.PP
The buffer is deep copied to a new buffer.
.RE
.PP
Ensure that our internal buffer is unshared. If needed, performs a deep copy into a new buffer (COW). Also take a hint size n of the new string's size as to avoid needless copying/allocing. 
.PP
Definition at line 75 of file String.cpp.
.SS "const char* String::data () const\fC [inline]\fP"
.PP
Data accessor. 
.PP
\fBReturns:\fP
.RS 4
Pointer to array of characters (not necesarily null-terminated). 
.RE
.PP

.PP
Definition at line 436 of file String.h.
.SS "bool String::hasIndex (int i) const\fC [inline]\fP"
.PP
Checks if the buffer has the given index or not. 
.PP
\fBReturns:\fP
.RS 4
Boolean true/false as to whether or not index exists. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Index to check. 
.RE
.PP

.PP
Definition at line 443 of file String.h.
.SS "void String::insert (int k, const \fBString\fP & string, int n = \fC-1\fP)"
.PP
Inserts a \fBString\fP object into our buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to insert at. 
.br
\fIstring\fP The string to insert. 
.br
\fIn\fP The length to insert. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer contains n characters from string inserted at index k. 
.RE
.PP

.PP
Definition at line 196 of file String.cpp.
.SS "void String::insert (int k, const char * string, int n = \fC-1\fP)"
.PP
Insert a cstring at the given index. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP The cstring to be inserted. 
.br
\fIk\fP The index to insert at. 
.br
\fIn\fP Up to this many characters will be used from the string. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A buffer is allocated. 
.PP
If the old buffer was too small, it is enlarged. 
.PP
The string is inserted at the given index. 
.RE
.PP

.PP
Definition at line 152 of file String.cpp.
.SS "void String::insert (int k, const char ch)"
.PP
Insert a character at the given index. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to insert at. 
.br
\fIch\fP The character to be inserted. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A buffer is allocated. 
.PP
If the old buffer was too small, it is enlarged. 
.PP
The character is inserted at the given index. 
.RE
.PP

.PP
Definition at line 119 of file String.cpp.
.SS "bool String::isEmpty () const\fC [inline]\fP"
.PP
Check whether the string is 'empty'. 
.PP
\fBReturns:\fP
.RS 4
True if empty, false if non-empty 
.RE
.PP

.PP
Definition at line 390 of file String.h.
.SS "size_t String::length () const\fC [inline]\fP"
.PP
Returns length of the string. 
.PP
\fBReturns:\fP
.RS 4
Length of the string. 
.RE
.PP

.PP
Definition at line 378 of file String.h.
.SS "bool String::operator! () const\fC [inline]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBisEmpty()\fP This is for: if (!string) Having if(string) conflicts with another operator 
.RE
.PP

.PP
Definition at line 396 of file String.h.
.SS "\fBString\fP String::operator() (int start, int len) const\fC [inline]\fP"
.PP
Returns a const substring. 
.PP
\fBSee also:\fP
.RS 4
SubString 
.RE
.PP

.PP
Definition at line 494 of file String.h.
.SS "SubString String::operator() (int start, int len)\fC [inline]\fP"
.PP
Returns a 'SubString' class for safe (cow) writing into \fBString\fP. 
.PP
\fBSee also:\fP
.RS 4
SubString 
.RE
.PP

.PP
Definition at line 489 of file String.h.
.SS "\fBString\fP String::operator* (int times) const"
.PP
This is a cast operator to const char* This would be used in this situation: \fBString\fP string('blah'); const char* cstring = (const char*) string;. 
.PP
\fBSee also:\fP
.RS 4
\fBc_str()\fP Returns a new \fBString\fP containing integer copies of the receiver. 
.RE
.PP
\fBReturns:\fP
.RS 4
a new \fBString\fP from Ruby 
.RE
.PP

.PP
Definition at line 376 of file String.cpp.
.SS "const char* String::operator* () const\fC [inline]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBc_str()\fP 
.RE
.PP

.PP
Definition at line 414 of file String.h.
.SS "\fBString\fP & String::operator+= (const \fBString\fP & string)\fC [inline]\fP"
.PP
\fBSee also:\fP
.RS 4
append(const String&) 
.RE
.PP

.PP
Definition at line 672 of file String.h.
.SS "\fBString\fP & String::operator+= (const char * string)\fC [inline]\fP"
.PP
\fBSee also:\fP
.RS 4
append(const char*) 
.RE
.PP

.PP
Definition at line 664 of file String.h.
.SS "\fBString\fP & String::operator+= (const char ch)\fC [inline]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBappend(const char)\fP 
.RE
.PP

.PP
Definition at line 656 of file String.h.
.SS "const \fBString\fP & String::operator= (const \fBString\fP & string)"
.PP
Sets our Reference to the given \fBString\fP reference. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP The \fBString\fP object to reference. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The old buffer (if we had one) is free'd. 
.PP
Our Reference now points to the given \fBString\fP. 
.PP
Our old string object has been deleted (disconnected). 
.RE
.PP
\fBReturns:\fP
.RS 4
The new string object. This handles self-assignment just fine, checking for it explicitly would be ineffecient for most cases. 
.RE
.PP

.PP
Definition at line 274 of file String.cpp.
.SS "const \fBString\fP & String::operator= (const char * string)\fC [virtual]\fP"
.PP
Sets our buffer to the given string. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP The string to set our buffer to. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The old buffer (if we had one) is free'd. 
.PP
A sufficiently sized new buffer is made with the string within. 
.RE
.PP
\fBReturns:\fP
.RS 4
The new string object. 
.RE
.PP

.PP
Definition at line 259 of file String.cpp.
.SS "const \fBString\fP & String::operator= (const char ch)\fC [virtual]\fP"
.PP
Sets our buffer to the given character. 
.PP
\fBParameters:\fP
.RS 4
\fIch\fP The character to set our buffer to. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The old buffer (if we had one) is free'd. 
.PP
A sufficiently sized new buffer is made with the character within. 
.RE
.PP
\fBReturns:\fP
.RS 4
The new string object. 
.RE
.PP

.PP
Definition at line 246 of file String.cpp.
.SS "Cref String::operator[] (int i)\fC [inline]\fP"
.PP
Returns 'Cref' class for safe (cow) writing into \fBString\fP. 
.PP
\fBSee also:\fP
.RS 4
Cref 
.RE
.PP

.PP
Definition at line 471 of file String.h.
.SS "char String::operator[] (int i) const\fC [inline]\fP"
.PP
Safe element access operator. 
.PP
\fBTodo\fP
.RS 4
This is only called on a (const) \fBString\fP, but should for a \fBString\fP as well. 
.RE
.PP

.PP
Definition at line 465 of file String.h.
.SS "char String::read (int i) const\fC [inline]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBcharAt()\fP Unlinke \fBcharAt()\fP this is unchecked. 
.RE
.PP

.PP
Definition at line 454 of file String.h.
.SS "void String::replace (int k, const \fBString\fP & string, int n = \fC-1\fP)"
.PP
Replaces n characters in our buffer at index k with the given \fBString\fP object. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to replace at. 
.br
\fIstring\fP The \fBString\fP object to replace with. 
.br
\fIn\fP The number of characters to use for the replace. 
.RE
.PP

.PP
Definition at line 217 of file String.cpp.
.SS "void String::replace (int k, const char * string, int n = \fC-1\fP)"
.PP
Replaces the given index with the given cstring up to the given amount of characters. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to replace at. 
.br
\fIstring\fP The cstring to replace with. 
.br
\fIn\fP How many characters to use from string. 
.RE
.PP

.PP
Definition at line 171 of file String.cpp.
.SS "void String::replace (int k, const char ch)"
.PP
Replace the given index with the given character. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to replace. 
.br
\fIch\fP The character to replace with. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The given index has been replaced. 
.PP
COW is done if needed. 
.RE
.PP

.PP
Definition at line 136 of file String.cpp.
.SS "virtual void String::Reserve (const size_t newSize) const\fC [inline, virtual]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBStringBuf::Reserve()\fP 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The \fBString\fP will also never shrink after this. 
.RE
.PP

.PP
Definition at line 547 of file String.h.
.SS "\fBString\fP String::substring (int start, int len) const"
.PP
Return a new string from a substring. 
.PP
\fBReturns:\fP
.RS 4
a new \fBString\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIstart\fP The offset to begin the substring from (indexed from 0) 
.br
\fIlen\fP The length of the substring to return The returned substring is a reference to the original string until modified. 
.RE
.PP

.PP
Definition at line 322 of file String.cpp.
.SH "Friends And Related Function Documentation"
.PP 
.SS "\fBString\fP operator+ (const \fBString\fP & string1, const \fBString\fP & string2)\fC [friend]\fP"
.PP
Concatenates two string objects together. 
.PP
\fBParameters:\fP
.RS 4
\fIstring1\fP The LHS string. 
.br
\fIstring2\fP The RHS string. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A new string is allocated, reference copied and returned. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns a new string that can be reference copied by the lvalue. 
.RE
.PP

.PP
Definition at line 620 of file String.h.
.SH "Member Data Documentation"
.PP 
.SS "size_t \fBString::offset\fP\fC [mutable, protected]\fP"
.PP
This is for substrings: so we know where the substring starts. 
.PP
Definition at line 267 of file String.h.
.SS "size_t \fBString::sublen\fP\fC [mutable, protected]\fP"
.PP
This is for substrings: so we know where the substring ends. 
.PP
Definition at line 271 of file String.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for BDLIB from the source code.
