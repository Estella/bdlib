.TH "String" 3 "18 Dec 2009" "Version 1.0" "BDLIB" \" -*- nroff -*-
.ad l
.nh
.SH NAME
String \- Provides custom string class for easy and optimized string manipulation.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <String.h>\fP
.PP
Inherits ReferenceCountedArray<String_Array_Type>.
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBString\fP (const \fBString\fP &string)"
.br
.ti -1c
.RI "\fBString\fP (const char *cstring)"
.br
.RI "\fICreate a \fBString\fP from a given cstring. \fP"
.ti -1c
.RI "\fBString\fP (const char *cstring, size_t slen)"
.br
.RI "\fICreate a \fBString\fP from a given cstring with the given strlen. \fP"
.ti -1c
.RI "\fBString\fP (const char ch)"
.br
.RI "\fICreate a \fBString\fP from a given character. \fP"
.ti -1c
.RI "\fBString\fP (const size_t newSize)"
.br
.RI "\fICreate an empty \fBString\fP container with at least the specified bytes in size. \fP"
.ti -1c
.RI "size_t \fBfind\fP (const \fBString\fP &) const "
.br
.ti -1c
.RI "const char * \fBc_str\fP () const "
.br
.RI "\fICstring accessor. \fP"
.ti -1c
.RI "const char * \fBoperator*\fP () const "
.br
.ti -1c
.RI "\fBString\fP \fBoperator*\fP (int) const "
.br
.RI "\fIThis is a cast operator to const char* This would be used in this situation: \fBString\fP string('blah'); const char* cstring = (const char*) string;. \fP"
.ti -1c
.RI "\fBString\fP & \fBchomp\fP ()"
.br
.RI "\fITrim off 
.br
,,
.br
 from end. \fP"
.ti -1c
.RI "\fBString\fP \fBchomp\fP () const "
.br
.RI "\fITrim off 
.br
,,
.br
 from end. \fP"
.ti -1c
.RI "\fBString\fP & \fBtrim\fP ()"
.br
.RI "\fITrim off whitespace. \fP"
.ti -1c
.RI "\fBString\fP \fBtrim\fP () const "
.br
.RI "\fITrim off whitespace. \fP"
.ti -1c
.RI "char \fBcharAt\fP (int i) const "
.br
.ti -1c
.RI "\fBString\fP \fBsubstring\fP (int start, int len) const "
.br
.ti -1c
.RI "\fBString\fP \fBoperator()\fP (int start, int len) const "
.br
.ti -1c
.RI "\fBSlice\fP< \fBString\fP > \fBoperator()\fP (int start, int len)"
.br
.RI "\fIReturns a 'Slice' class for safe (cow) writing into the array. \fP"
.ti -1c
.RI "virtual size_t \fBhash\fP () const "
.br
.RI "\fIDJB's hash function. \fP"
.ti -1c
.RI "int \fBcompare\fP (const \fBString\fP &string) const "
.br
.RI "\fICompare our \fBString\fP object with another \fBString\fP object. \fP"
.ti -1c
.RI "int \fBcompare\fP (const \fBString\fP &, size_t) const "
.br
.RI "\fICompare our \fBString\fP object with another \fBString\fP object, but only n characters. \fP"
.ti -1c
.RI "Array< \fBString\fP > \fBsplit\fP (const \fBString\fP &, size_t limit=npos) const "
.br
.ti -1c
.RI "void \fBappend\fP (const char *string, int n=-1)"
.br
.RI "\fIAppends given cstring to end of buffer. \fP"
.ti -1c
.RI "void \fBinsert\fP (int, const char *, int=-1)"
.br
.RI "\fIInsert a cstring at the given index. \fP"
.ti -1c
.RI "void \fBreplace\fP (int, const char *, int=-1)"
.br
.RI "\fIReplaces the given index with the given cstring up to the given amount of characters. \fP"
.ti -1c
.RI "virtual \fBString\fP \fBprintf\fP (const char *,...)"
.br
.ti -1c
.RI "\fBString\fP & \fBoperator+=\fP (const char)"
.br
.ti -1c
.RI "\fBString\fP & \fBoperator+=\fP (const char *)"
.br
.ti -1c
.RI "\fBString\fP & \fBoperator+=\fP (const \fBString\fP &)"
.br
.ti -1c
.RI "\fBString\fP & \fBoperator+=\fP (int)"
.br
.ti -1c
.RI "\fBString\fP & \fBoperator-=\fP (int)"
.br
.ti -1c
.RI "const \fBString\fP & \fBoperator++\fP ()"
.br
.ti -1c
.RI "const \fBString\fP \fBoperator++\fP (int)"
.br
.ti -1c
.RI "const \fBString\fP & \fBoperator--\fP ()"
.br
.ti -1c
.RI "const \fBString\fP \fBoperator--\fP (int)"
.br
.ti -1c
.RI "virtual const \fBString\fP & \fBoperator=\fP (const char *)"
.br
.RI "\fISets our buffer to the given string. \fP"
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const size_t \fBnpos\fP = size_t(-1)"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "\fBString\fP \fBoperator+\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.RI "\fIConcatenates two string objects together. \fP"
.ti -1c
.RI "bool \fBoperator==\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "bool \fBoperator>\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &, const \fBString\fP &)"
.br
.ti -1c
.RI "std::ostream & \fBoperator>>\fP (std::ostream &, const \fBString\fP &)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Provides custom string class for easy and optimized string manipulation. 

\fBTodo\fP
.RS 4
compute hash on insert, then use to compare instead of strcmp 
.PP
an updating hash as the copy is done. 
.RE
.PP

.PP
Definition at line 60 of file String.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "String::String (const char * cstring)\fC [inline]\fP"
.PP
Create a \fBString\fP from a given cstring. 
.PP
\fBParameters:\fP
.RS 4
\fIcstring\fP The null-terminated character array to create the object from. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A \fBStringBuf\fP has been initialized. 
.PP
The buffer has been filled with the string. 
.RE
.PP
\fBTest\fP
.RS 4
\fBString\fP test('Some string'); 
.RE
.PP

.PP
Definition at line 79 of file String.h.
.SS "String::String (const char * cstring, size_t slen)\fC [inline]\fP"
.PP
Create a \fBString\fP from a given cstring with the given strlen. 
.PP
\fBParameters:\fP
.RS 4
\fIcstring\fP The null-terminated character array to create the object from. 
.br
\fIslen\fP The length of the given string to use. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
len > 0 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A \fBStringBuf\fP has been initialized. 
.PP
The buffer has been filled with the string (up to len characters). 
.RE
.PP
\fBTest\fP
.RS 4
\fBString\fP test('Some string'); 
.RE
.PP

.PP
Definition at line 90 of file String.h.
.SS "String::String (const char ch)\fC [inline]\fP"
.PP
Create a \fBString\fP from a given character. 
.PP
\fBParameters:\fP
.RS 4
\fIch\fP The character to create the string from. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A stringBuf has been initialized. 
.PP
The buffer has been filled with the caracter. 
.RE
.PP
\fBTest\fP
.RS 4
\fBString\fP test('a'); 
.RE
.PP

.PP
Definition at line 99 of file String.h.
.SS "String::String (const size_t newSize)\fC [inline, explicit]\fP"
.PP
Create an empty \fBString\fP container with at least the specified bytes in size. 
.PP
\fBParameters:\fP
.RS 4
\fInewSize\fP Reserve at least this many bytes for this \fBString\fP. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
This string's memory will also never be shrunk. 
.PP
A buffer has been created.
.RE
.PP
The idea behind this is that if a specific size was asked for, the buffer is like a char buf[N]; 
.PP
Definition at line 110 of file String.h.
.SH "Member Function Documentation"
.PP 
.SS "void String::append (const char * string, int n = \fC-1\fP)\fC [inline]\fP"
.PP
Appends given cstring to end of buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP The cstring to be appended. 
.br
\fIn\fP How many characters to copy from the string. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer is allocated. This is the same as inserting the string at the end of the buffer. 
.RE
.PP

.PP
Definition at line 224 of file String.h.
.SS "const char* String::c_str () const\fC [inline]\fP"
.PP
Cstring accessor. 
.PP
\fBReturns:\fP
.RS 4
A null-terminated character array (cstring). 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer size is (possibly) incremented by 1 for the '' character. 
.PP
There is a '' at the end of the buffer. 
.PP
The actual \fBString\fP size is unchanged. 
.RE
.PP

.PP
Definition at line 129 of file String.h.
.SS "\fBString\fP String::chomp () const\fC [inline]\fP"
.PP
Trim off 
.br
,,
.br
 from end. 
.PP
\fBReturns:\fP
.RS 4
New string 
.RE
.PP

.PP
Definition at line 166 of file String.h.
.SS "\fBString\fP & String::chomp ()"
.PP
Trim off 
.br
,,
.br
 from end. 
.PP
\fBReturns:\fP
.RS 4
The string, to allow for chaining 
.RE
.PP

.PP
Definition at line 227 of file String.cpp.
.SS "int String::compare (const \fBString\fP & str, size_t n) const"
.PP
Compare our \fBString\fP object with another \fBString\fP object, but only n characters. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP The \fBString\fP object to compare to. 
.br
\fIn\fP The number of characters to compare. 
.RE
.PP
\fBReturns:\fP
.RS 4
an integer less than, equal to, or greater than zero if our buffer is found, respectively, to be less than, to match, or be greater than str. 
.RE
.PP

.PP
Definition at line 47 of file String.cpp.
.SS "int String::compare (const \fBString\fP & string) const\fC [inline]\fP"
.PP
Compare our \fBString\fP object with another \fBString\fP object. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP The \fBString\fP object to compare to 
.RE
.PP
\fBReturns:\fP
.RS 4
an integer less than, equal to, or greater than zero if our buffer is found, respectively, to be less than, to match, or be greater than str. 
.RE
.PP

.PP
Definition at line 212 of file String.h.
.SS "void String::insert (int k, const char * string, int n = \fC-1\fP)"
.PP
Insert a cstring at the given index. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP The cstring to be inserted. 
.br
\fIk\fP The index to insert at. 
.br
\fIn\fP Up to this many characters will be used from the string. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A buffer is allocated. 
.PP
If the old buffer was too small, it is enlarged. 
.PP
The string is inserted at the given index. 
.RE
.PP

.PP
Definition at line 77 of file String.cpp.
.SS "\fBSlice\fP<\fBString\fP> String::operator() (int start, int len)\fC [inline]\fP"
.PP
Returns a 'Slice' class for safe (cow) writing into the array. 
.PP
\fBSee also:\fP
.RS 4
\fBSlice\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIstart\fP Starting position 
.br
\fIlen\fP How many items to use 
.RE
.PP

.PP
Definition at line 203 of file String.h.
.SS "\fBString\fP String::operator* (int times) const"
.PP
This is a cast operator to const char* This would be used in this situation: \fBString\fP string('blah'); const char* cstring = (const char*) string;. 
.PP
\fBSee also:\fP
.RS 4
\fBc_str()\fP Returns a new \fBString\fP containing integer copies of the receiver. 
.RE
.PP
\fBReturns:\fP
.RS 4
a new \fBString\fP from Ruby 
.RE
.PP

.PP
Definition at line 209 of file String.cpp.
.SS "const char* String::operator* () const\fC [inline]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBc_str()\fP 
.RE
.PP

.PP
Definition at line 138 of file String.h.
.SS "\fBString\fP & String::operator+= (const \fBString\fP & string)\fC [inline]\fP"
.PP
\fBSee also:\fP
.RS 4
append(const String&) 
.RE
.PP

.PP
Definition at line 355 of file String.h.
.SS "\fBString\fP & String::operator+= (const char * string)\fC [inline]\fP"
.PP
\fBSee also:\fP
.RS 4
append(const char*) 
.RE
.PP

.PP
Definition at line 347 of file String.h.
.SS "\fBString\fP & String::operator+= (const char ch)\fC [inline]\fP"
.PP
\fBSee also:\fP
.RS 4
append(const char) 
.RE
.PP

.PP
Definition at line 339 of file String.h.
.SS "const \fBString\fP & String::operator= (const char * string)\fC [virtual]\fP"
.PP
Sets our buffer to the given string. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP The string to set our buffer to. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The old buffer (if we had one) is free'd. 
.PP
A sufficiently sized new buffer is made with the string within. 
.RE
.PP
\fBReturns:\fP
.RS 4
The new string object. 
.RE
.PP

.PP
Definition at line 121 of file String.cpp.
.SS "void String::replace (int k, const char * string, int n = \fC-1\fP)"
.PP
Replaces the given index with the given cstring up to the given amount of characters. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to replace at. 
.br
\fIstring\fP The cstring to replace with. 
.br
\fIn\fP How many characters to use from string. 
.RE
.PP

.PP
Definition at line 96 of file String.cpp.
.SS "\fBString\fP String::trim () const\fC [inline]\fP"
.PP
Trim off whitespace. 
.PP
\fBReturns:\fP
.RS 4
New string 
.RE
.PP

.PP
Definition at line 178 of file String.h.
.SS "\fBString\fP & String::trim ()"
.PP
Trim off whitespace. 
.PP
\fBReturns:\fP
.RS 4
The string, to allow for chaining 
.RE
.PP

.PP
Definition at line 233 of file String.cpp.
.SH "Friends And Related Function Documentation"
.PP 
.SS "\fBString\fP operator+ (const \fBString\fP & string1, const \fBString\fP & string2)\fC [friend]\fP"
.PP
Concatenates two string objects together. 
.PP
\fBParameters:\fP
.RS 4
\fIstring1\fP The LHS string. 
.br
\fIstring2\fP The RHS string. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A new string is allocated, reference copied and returned. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns a new string that can be reference copied by the lvalue. 
.RE
.PP

.PP
Definition at line 303 of file String.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for BDLIB from the source code.
