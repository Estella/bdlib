.TH "String" 3 "18 Dec 2009" "Version 1.0" "BDLIB" \" -*- nroff -*-
.ad l
.nh
.SH NAME
String \- Provides custom string class for easy and optimized string manipulation.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <String.h>\fP
.PP
Inherits \fBReferenceCountedArray< String_Array_Type >\fP.
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef const \fBvalue_type\fP * \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef const \fBvalue_type\fP & \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef ptrdiff_t \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef \fBvalue_type\fP * \fBpointer\fP"
.br
.ti -1c
.RI "typedef \fBvalue_type\fP & \fBreference\fP"
.br
.ti -1c
.RI "typedef size_t \fBsize_type\fP"
.br
.ti -1c
.RI "typedef \fBString_Array_Type\fP \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBappend\fP (const \fBReferenceCountedArray\fP &rca, int n=-1)"
.br
.RI "\fIAppends given rca to the end of buffer. \fP"
.ti -1c
.RI "void \fBappend\fP (\fBconst_reference\fP item)"
.br
.RI "\fIAppends one item to end of buffer. \fP"
.ti -1c
.RI "void \fBappend\fP (const char *string, int n=-1)"
.br
.RI "\fIAppends given cstring to end of buffer. \fP"
.ti -1c
.RI "\fBvalue_type\fP \fBat\fP (int i) const"
.br
.RI "\fIReturns the character at the given index. \fP"
.ti -1c
.RI "\fBconst_pointer\fP \fBbegin\fP () const"
.br
.ti -1c
.RI "const char * \fBc_str\fP () const "
.br
.RI "\fICstring accessor. \fP"
.ti -1c
.RI "size_t \fBcapacity\fP () const"
.br
.RI "\fIReturns capacity of the \fBString\fP object. \fP"
.ti -1c
.RI "char \fBcharAt\fP (int i) const "
.br
.ti -1c
.RI "\fBString\fP \fBchomp\fP () const "
.br
.RI "\fITrim off 
.br
,,
.br
 from end. \fP"
.ti -1c
.RI "\fBString\fP & \fBchomp\fP ()"
.br
.RI "\fITrim off 
.br
,,
.br
 from end. \fP"
.ti -1c
.RI "virtual void \fBclear\fP ()"
.br
.RI "\fIClear contents of \fBString\fP and set length to 0. \fP"
.ti -1c
.RI "int \fBcompare\fP (const \fBString\fP &, size_t) const "
.br
.RI "\fICompare our \fBString\fP object with another \fBString\fP object, but only n characters. \fP"
.ti -1c
.RI "int \fBcompare\fP (const \fBString\fP &string) const "
.br
.RI "\fICompare our \fBString\fP object with another \fBString\fP object. \fP"
.ti -1c
.RI "\fBconst_pointer\fP \fBdata\fP () const"
.br
.RI "\fIData accessor. \fP"
.ti -1c
.RI "\fBconst_pointer\fP \fBend\fP () const"
.br
.ti -1c
.RI "size_t \fBfind\fP (\fBconst_reference\fP item) const"
.br
.ti -1c
.RI "size_t \fBfind\fP (const \fBString\fP &) const "
.br
.ti -1c
.RI "virtual size_t \fBhash\fP () const "
.br
.RI "\fIDJB's hash function. \fP"
.ti -1c
.RI "bool \fBhasIndex\fP (int i) const"
.br
.RI "\fIChecks if the buffer has the given index or not. \fP"
.ti -1c
.RI "void \fBinsert\fP (int k, \fBconst_reference\fP item)"
.br
.RI "\fIInsert an item at the given index. \fP"
.ti -1c
.RI "void \fBinsert\fP (int k, const \fBReferenceCountedArray\fP &rca, int n=-1)"
.br
.RI "\fIInserts a \fBReferenceCountedArray\fP object into our buffer. \fP"
.ti -1c
.RI "void \fBinsert\fP (int, const char *, int=-1)"
.br
.RI "\fIInsert a cstring at the given index. \fP"
.ti -1c
.RI "bool \fBisEmpty\fP () const"
.br
.RI "\fICheck whether the string is 'empty'. \fP"
.ti -1c
.RI "bool \fBisShared\fP () const"
.br
.ti -1c
.RI "size_t \fBlength\fP () const"
.br
.RI "\fIReturns length of the string. \fP"
.ti -1c
.RI "bool \fBoperator!\fP () const"
.br
.ti -1c
.RI "\fBSlice\fP< \fBString\fP > \fBoperator()\fP (int start, int len)"
.br
.RI "\fIReturns a 'Slice' class for safe (cow) writing into the array. \fP"
.ti -1c
.RI "\fBString\fP \fBoperator()\fP (int start, int len) const "
.br
.ti -1c
.RI "\fBString\fP \fBoperator*\fP (int) const "
.br
.RI "\fIThis is a cast operator to const char* This would be used in this situation: \fBString\fP string('blah'); const char* cstring = (const char*) string;. \fP"
.ti -1c
.RI "const char * \fBoperator*\fP () const "
.br
.ti -1c
.RI "const \fBString\fP \fBoperator++\fP (int)"
.br
.ti -1c
.RI "const \fBString\fP & \fBoperator++\fP ()"
.br
.ti -1c
.RI "\fBString\fP & \fBoperator+=\fP (int)"
.br
.ti -1c
.RI "\fBString\fP & \fBoperator+=\fP (const \fBString\fP &)"
.br
.ti -1c
.RI "\fBString\fP & \fBoperator+=\fP (const char *)"
.br
.ti -1c
.RI "\fBString\fP & \fBoperator+=\fP (const char)"
.br
.ti -1c
.RI "const \fBString\fP \fBoperator--\fP (int)"
.br
.ti -1c
.RI "const \fBString\fP & \fBoperator--\fP ()"
.br
.ti -1c
.RI "\fBString\fP & \fBoperator-=\fP (int)"
.br
.ti -1c
.RI "Cref \fBoperator[]\fP (int i)"
.br
.RI "\fIReturns 'Cref' class for safe (cow) writing into \fBString\fP. \fP"
.ti -1c
.RI "\fBvalue_type\fP \fBoperator[]\fP (int i) const"
.br
.RI "\fISafe element access operator. \fP"
.ti -1c
.RI "virtual \fBString\fP \fBprintf\fP (const char *,...)"
.br
.ti -1c
.RI "size_t \fBrcount\fP () const"
.br
.ti -1c
.RI "\fBvalue_type\fP \fBread\fP (int i) const"
.br
.ti -1c
.RI "void \fBreplace\fP (int k, const \fBReferenceCountedArray\fP &rca, int n=-1)"
.br
.RI "\fIReplaces n elements in our buffer at index k with the given \fBReferenceCountedArray\fP object. \fP"
.ti -1c
.RI "void \fBreplace\fP (int k, \fBconst_reference\fP item)"
.br
.RI "\fIReplace the given index with the given item. \fP"
.ti -1c
.RI "void \fBreplace\fP (int, const char *, int=-1)"
.br
.RI "\fIReplaces the given index with the given cstring up to the given amount of characters. \fP"
.ti -1c
.RI "virtual void \fBReserve\fP (const size_t newSize) const"
.br
.ti -1c
.RI "size_t \fBsize\fP () const"
.br
.ti -1c
.RI "void \fBslice\fP (int start, int len)"
.br
.RI "\fIReturn a new array from a subarray. \fP"
.ti -1c
.RI "\fBArray\fP< \fBString\fP > \fBsplit\fP (const \fBString\fP &, size_t limit=\fBnpos\fP) const "
.br
.ti -1c
.RI "\fBString\fP (const size_t newSize)"
.br
.RI "\fICreate an empty \fBString\fP container with at least the specified bytes in size. \fP"
.ti -1c
.RI "\fBString\fP (const char ch)"
.br
.RI "\fICreate a \fBString\fP from a given character. \fP"
.ti -1c
.RI "\fBString\fP (const char *cstring, size_t slen)"
.br
.RI "\fICreate a \fBString\fP from a given cstring with the given strlen. \fP"
.ti -1c
.RI "\fBString\fP (const char *cstring)"
.br
.RI "\fICreate a \fBString\fP from a given cstring. \fP"
.ti -1c
.RI "\fBString\fP (const \fBString\fP &string)"
.br
.ti -1c
.RI "\fBString\fP ()"
.br
.ti -1c
.RI "\fBString\fP \fBsubstring\fP (int start, int len) const "
.br
.ti -1c
.RI "\fBString\fP \fBtrim\fP () const "
.br
.RI "\fITrim off whitespace. \fP"
.ti -1c
.RI "\fBString\fP & \fBtrim\fP ()"
.br
.RI "\fITrim off whitespace. \fP"
.ti -1c
.RI "void \fBwrite\fP (int i, \fBvalue_type\fP item)"
.br
.ti -1c
.RI "virtual \fB~String\fP ()"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const size_t \fBnpos\fP = size_t(-1)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBAboutToModify\fP (size_t n) const"
.br
.ti -1c
.RI "void \fBaddLength\fP (size_t diff) const"
.br
.ti -1c
.RI "\fBpointer\fP \fBBuf\fP (int i=0) const"
.br
.RI "\fIMutable Ref->buf+offset reference for use internally. \fP"
.ti -1c
.RI "\fBconst_pointer\fP \fBconstBuf\fP (int i=0) const"
.br
.RI "\fIRef->buf reference for use internally. \fP"
.ti -1c
.RI "void \fBgetOwnCopy\fP () const"
.br
.ti -1c
.RI "void \fBsetLength\fP (size_t newLen) const"
.br
.RI "\fISet the lengths to the specified length. \fP"
.ti -1c
.RI "void \fBsubLength\fP (size_t diff) const"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "size_t \fBoffset\fP"
.br
.ti -1c
.RI "size_t \fBsublen\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "\fBString\fP \fBoperator+\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.RI "\fIConcatenates two string objects together. \fP"
.ti -1c
.RI "bool \fBoperator<\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &, const \fBString\fP &)"
.br
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "bool \fBoperator>\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBString\fP &, const \fBString\fP &)"
.br
.ti -1c
.RI "std::ostream & \fBoperator>>\fP (std::ostream &, const \fBString\fP &)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Provides custom string class for easy and optimized string manipulation. 

\fBTodo\fP
.RS 4
compute hash on insert, then use to compare instead of strcmp 
.PP
an updating hash as the copy is done. 
.RE
.PP

.PP
Definition at line 59 of file String.h.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef const \fBvalue_type\fP* \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::\fBconst_pointer\fP\fC [inherited]\fP"
.PP
Definition at line 171 of file ReferenceCountedArray.h.
.SS "typedef const \fBvalue_type\fP& \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::\fBconst_reference\fP\fC [inherited]\fP"
.PP
Definition at line 173 of file ReferenceCountedArray.h.
.SS "typedef ptrdiff_t \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::\fBdifference_type\fP\fC [inherited]\fP"
.PP
Definition at line 169 of file ReferenceCountedArray.h.
.SS "typedef \fBvalue_type\fP* \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::\fBpointer\fP\fC [inherited]\fP"
.PP
Definition at line 170 of file ReferenceCountedArray.h.
.SS "typedef \fBvalue_type\fP& \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::\fBreference\fP\fC [inherited]\fP"
.PP
Definition at line 172 of file ReferenceCountedArray.h.
.SS "typedef size_t \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::\fBsize_type\fP\fC [inherited]\fP"
.PP
Definition at line 168 of file ReferenceCountedArray.h.
.SS "typedef \fBString_Array_Type\fP  \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::\fBvalue_type\fP\fC [inherited]\fP"
.PP
Definition at line 166 of file ReferenceCountedArray.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "String::String ()\fC [inline]\fP"
.PP
Definition at line 69 of file String.h.
.SS "String::String (const \fBString\fP & string)\fC [inline]\fP"
.PP
Definition at line 70 of file String.h.
.SS "String::String (const char * cstring)\fC [inline]\fP"
.PP
Create a \fBString\fP from a given cstring. 
.PP
\fBParameters:\fP
.RS 4
\fIcstring\fP The null-terminated character array to create the object from. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer has been filled with the string. 
.RE
.PP
\fBTest\fP
.RS 4
\fBString\fP test('Some string'); 
.RE
.PP

.PP
Definition at line 77 of file String.h.
.SS "String::String (const char * cstring, size_t slen)\fC [inline]\fP"
.PP
Create a \fBString\fP from a given cstring with the given strlen. 
.PP
\fBParameters:\fP
.RS 4
\fIcstring\fP The null-terminated character array to create the object from. 
.br
\fIslen\fP The length of the given string to use. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
len > 0 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer has been filled with the string (up to len characters). 
.RE
.PP
\fBTest\fP
.RS 4
\fBString\fP test('Some string'); 
.RE
.PP

.PP
Definition at line 87 of file String.h.
.SS "String::String (const char ch)\fC [inline]\fP"
.PP
Create a \fBString\fP from a given character. 
.PP
\fBParameters:\fP
.RS 4
\fIch\fP The character to create the string from. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A stringBuf has been initialized. 
.PP
The buffer has been filled with the caracter. 
.RE
.PP
\fBTest\fP
.RS 4
\fBString\fP test('a'); 
.RE
.PP

.PP
Definition at line 96 of file String.h.
.SS "String::String (const size_t newSize)\fC [inline, explicit]\fP"
.PP
Create an empty \fBString\fP container with at least the specified bytes in size. 
.PP
\fBParameters:\fP
.RS 4
\fInewSize\fP Reserve at least this many bytes for this \fBString\fP. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
This string's memory will also never be shrunk. 
.PP
A buffer has been created.
.RE
.PP
The idea behind this is that if a specific size was asked for, the buffer is like a char buf[N]; 
.PP
Definition at line 107 of file String.h.
.SS "virtual String::~String ()\fC [inline, virtual]\fP"
.PP
Definition at line 110 of file String.h.
.SH "Member Function Documentation"
.PP 
.SS "void \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::AboutToModify (size_t n) const\fC [inline, protected, inherited]\fP"
.PP
Definition at line 297 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::addLength (size_t diff) const\fC [inline, protected, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBsetLength()\fP 
.RE
.PP

.PP
Definition at line 207 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::append (const \fBReferenceCountedArray\fP< \fBString_Array_Type\fP > & rca, int n = \fC-1\fP)\fC [inline, inherited]\fP"
.PP
Appends given rca to the end of buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIrca\fP The rca to be appended. 
.br
\fIn\fP How many characters to copy from the \fBReferenceCountedArray\fP object. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer is allocated. This is the same as inserting the rca at the end of the buffer. 
.RE
.PP

.PP
Definition at line 570 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::append (\fBconst_reference\fP item)\fC [inline, inherited]\fP"
.PP
Appends one item to end of buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIitem\fP The item to be appended. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer is allocated. 
.PP
The item is appended at the end of the buffer. This is the same as inserting the item at the end of the buffer. 
.RE
.PP

.PP
Definition at line 562 of file ReferenceCountedArray.h.
.SS "void String::append (const char * string, int n = \fC-1\fP)\fC [inline]\fP"
.PP
Appends given cstring to end of buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP The cstring to be appended. 
.br
\fIn\fP How many characters to copy from the string. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer is allocated. This is the same as inserting the string at the end of the buffer. 
.RE
.PP

.PP
Definition at line 221 of file String.h.
.SS "\fBvalue_type\fP \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::at (int i) const\fC [inline, inherited]\fP"
.PP
Returns the character at the given index. 
.PP
\fBReturns:\fP
.RS 4
The character at the given index. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Index to return. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
The index must exist. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator[]()\fP 
.RE
.PP
\fBTodo\fP
.RS 4
Perhaps this should throw an exception if out of range? 
.RE
.PP

.PP
Definition at line 520 of file ReferenceCountedArray.h.
.SS "\fBconst_pointer\fP \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::begin () const\fC [inline, inherited]\fP"
.PP
Definition at line 416 of file ReferenceCountedArray.h.
.SS "\fBpointer\fP \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::Buf (int i = \fC0\fP) const\fC [inline, protected, inherited]\fP"
.PP
Mutable Ref->buf+offset reference for use internally. 
.PP
Mutable Ref->buf reference for use internally 
.PP
Definition at line 222 of file ReferenceCountedArray.h.
.SS "const char* String::c_str () const\fC [inline]\fP"
.PP
Cstring accessor. 
.PP
\fBReturns:\fP
.RS 4
A null-terminated character array (cstring). 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer size is (possibly) incremented by 1 for the '' character. 
.PP
There is a '' at the end of the buffer. 
.PP
The actual \fBString\fP size is unchanged. 
.RE
.PP

.PP
Definition at line 126 of file String.h.
.SS "size_t \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::capacity () const\fC [inline, inherited]\fP"
.PP
Returns capacity of the \fBString\fP object. 
.PP
\fBReturns:\fP
.RS 4
Capacity of the \fBString\fP object. 
.RE
.PP

.PP
Definition at line 385 of file ReferenceCountedArray.h.
.SS "char String::charAt (int i) const\fC [inline]\fP"
.PP
Definition at line 177 of file String.h.
.SS "\fBString\fP String::chomp () const\fC [inline]\fP"
.PP
Trim off 
.br
,,
.br
 from end. 
.PP
\fBReturns:\fP
.RS 4
New string 
.RE
.PP

.PP
Definition at line 163 of file String.h.
.SS "\fBString\fP & String::chomp ()"
.PP
Trim off 
.br
,,
.br
 from end. 
.PP
\fBReturns:\fP
.RS 4
The string, to allow for chaining 
.RE
.PP

.PP
Definition at line 214 of file String.cpp.
.SS "virtual void \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::clear ()\fC [inline, virtual, inherited]\fP"
.PP
Clear contents of \fBString\fP and set length to 0. 
.PP
Definition at line 379 of file ReferenceCountedArray.h.
.SS "int String::compare (const \fBString\fP & str, size_t n) const"
.PP
Compare our \fBString\fP object with another \fBString\fP object, but only n characters. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP The \fBString\fP object to compare to. 
.br
\fIn\fP The number of characters to compare. 
.RE
.PP
\fBReturns:\fP
.RS 4
an integer less than, equal to, or greater than zero if our buffer is found, respectively, to be less than, to match, or be greater than str. 
.RE
.PP

.PP
Definition at line 47 of file String.cpp.
.SS "int String::compare (const \fBString\fP & string) const\fC [inline]\fP"
.PP
Compare our \fBString\fP object with another \fBString\fP object. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP The \fBString\fP object to compare to 
.RE
.PP
\fBReturns:\fP
.RS 4
an integer less than, equal to, or greater than zero if our buffer is found, respectively, to be less than, to match, or be greater than str. 
.RE
.PP

.PP
Definition at line 209 of file String.h.
.SS "\fBconst_pointer\fP \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::constBuf (int i = \fC0\fP) const\fC [inline, protected, inherited]\fP"
.PP
Ref->buf reference for use internally. 
.PP
Definition at line 227 of file ReferenceCountedArray.h.
.SS "\fBconst_pointer\fP \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::data () const\fC [inline, inherited]\fP"
.PP
Data accessor. 
.PP
\fBReturns:\fP
.RS 4
Pointer to array of characters (not necesarily null-terminated). 
.RE
.PP

.PP
Definition at line 415 of file ReferenceCountedArray.h.
.SS "\fBconst_pointer\fP \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::end () const\fC [inline, inherited]\fP"
.PP
Definition at line 417 of file ReferenceCountedArray.h.
.SS "size_t \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::find (\fBconst_reference\fP item) const\fC [inline, inherited]\fP"
.PP
Definition at line 425 of file ReferenceCountedArray.h.
.SS "size_t String::find (const \fBString\fP & str) const"
.PP
Definition at line 228 of file String.cpp.
.SS "void \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::getOwnCopy () const\fC [inline, protected, inherited]\fP"
.PP
Definition at line 296 of file ReferenceCountedArray.h.
.SS "size_t String::hash () const\fC [virtual]\fP"
.PP
DJB's hash function. 
.PP
Implements \fBReferenceCountedArray< String_Array_Type >\fP.
.PP
Definition at line 238 of file String.cpp.
.SS "bool \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::hasIndex (int i) const\fC [inline, inherited]\fP"
.PP
Checks if the buffer has the given index or not. 
.PP
\fBReturns:\fP
.RS 4
Boolean true/false as to whether or not index exists. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Index to check. 
.RE
.PP

.PP
Definition at line 438 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::insert (int k, \fBconst_reference\fP item)\fC [inline, inherited]\fP"
.PP
Insert an item at the given index. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to insert at. 
.br
\fIitem\fP The item to be inserted. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A buffer is allocated. 
.PP
If the old buffer was too small, it is enlarged. 
.PP
The item is inserted at the given index. 
.RE
.PP

.PP
Definition at line 609 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::insert (int k, const \fBReferenceCountedArray\fP< \fBString_Array_Type\fP > & rca, int n = \fC-1\fP)\fC [inline, inherited]\fP"
.PP
Inserts a \fBReferenceCountedArray\fP object into our buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to insert at. 
.br
\fIrca\fP The rca to insert. 
.br
\fIn\fP The length to insert. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer contains n items from rca inserted at index k. 
.RE
.PP

.PP
Definition at line 580 of file ReferenceCountedArray.h.
.SS "void String::insert (int k, const char * string, int n = \fC-1\fP)"
.PP
Insert a cstring at the given index. 
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP The cstring to be inserted. 
.br
\fIk\fP The index to insert at. 
.br
\fIn\fP Up to this many characters will be used from the string. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A buffer is allocated. 
.PP
If the old buffer was too small, it is enlarged. 
.PP
The string is inserted at the given index. 
.RE
.PP

.PP
Definition at line 77 of file String.cpp.
.SS "bool \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::isEmpty () const\fC [inline, inherited]\fP"
.PP
Check whether the string is 'empty'. 
.PP
\fBReturns:\fP
.RS 4
True if empty, false if non-empty 
.RE
.PP

.PP
Definition at line 403 of file ReferenceCountedArray.h.
.SS "bool \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::isShared () const\fC [inline, inherited]\fP"
.PP
\fBReturns:\fP
.RS 4
True if this object is shared; false if not. 
.RE
.PP

.PP
Definition at line 367 of file ReferenceCountedArray.h.
.SS "size_t \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::length () const\fC [inline, inherited]\fP"
.PP
Returns length of the string. 
.PP
\fBReturns:\fP
.RS 4
Length of the string. 
.RE
.PP

.PP
Definition at line 393 of file ReferenceCountedArray.h.
.SS "bool \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::operator! () const\fC [inline, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBisEmpty()\fP This is for: if (!string) Having if(string) conflicts with another operator 
.RE
.PP

.PP
Definition at line 409 of file ReferenceCountedArray.h.
.SS "\fBSlice\fP<\fBString\fP> String::operator() (int start, int len)\fC [inline]\fP"
.PP
Returns a 'Slice' class for safe (cow) writing into the array. 
.PP
\fBSee also:\fP
.RS 4
\fBSlice\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIstart\fP Starting position 
.br
\fIlen\fP How many items to use 
.RE
.PP

.PP
Definition at line 200 of file String.h.
.SS "\fBString\fP String::operator() (int start, int len) const\fC [inline]\fP"
.PP
Definition at line 192 of file String.h.
.SS "\fBString\fP String::operator* (int times) const"
.PP
This is a cast operator to const char* This would be used in this situation: \fBString\fP string('blah'); const char* cstring = (const char*) string;. 
.PP
\fBSee also:\fP
.RS 4
\fBc_str()\fP Returns a new \fBString\fP containing integer copies of the receiver. 
.RE
.PP
\fBReturns:\fP
.RS 4
a new \fBString\fP from Ruby 
.RE
.PP

.PP
Definition at line 196 of file String.cpp.
.SS "const char* String::operator* () const\fC [inline]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBc_str()\fP 
.RE
.PP

.PP
Definition at line 135 of file String.h.
.SS "const \fBString\fP String::operator++ (int)\fC [inline]\fP"
.PP
Definition at line 309 of file String.h.
.SS "const \fBString\fP & String::operator++ ()\fC [inline]\fP"
.PP
Definition at line 305 of file String.h.
.SS "\fBString\fP & String::operator+= (int n)\fC [inline]\fP"
.PP
Definition at line 356 of file String.h.
.SS "\fBString\fP & String::operator+= (const \fBString\fP & string)\fC [inline]\fP"
.PP
\fBSee also:\fP
.RS 4
append(const String&) 
.RE
.PP

.PP
Definition at line 351 of file String.h.
.SS "\fBString\fP & String::operator+= (const char * string)\fC [inline]\fP"
.PP
\fBSee also:\fP
.RS 4
append(const char*) 
.RE
.PP

.PP
Definition at line 343 of file String.h.
.SS "\fBString\fP & String::operator+= (const char ch)\fC [inline]\fP"
.PP
\fBSee also:\fP
.RS 4
append(const char) 
.RE
.PP

.PP
Definition at line 335 of file String.h.
.SS "const \fBString\fP String::operator-- (int)\fC [inline]\fP"
.PP
Definition at line 320 of file String.h.
.SS "const \fBString\fP & String::operator-- ()\fC [inline]\fP"
.PP
Definition at line 316 of file String.h.
.SS "\fBString\fP & String::operator-= (int n)\fC [inline]\fP"
.PP
Definition at line 369 of file String.h.
.SS "Cref \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::operator[] (int i)\fC [inline, inherited]\fP"
.PP
Returns 'Cref' class for safe (cow) writing into \fBString\fP. 
.PP
\fBSee also:\fP
.RS 4
Cref 
.RE
.PP

.PP
Definition at line 510 of file ReferenceCountedArray.h.
.SS "\fBvalue_type\fP \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::operator[] (int i) const\fC [inline, inherited]\fP"
.PP
Safe element access operator. 
.PP
\fBTodo\fP
.RS 4
This is only called on a (const) \fBString\fP, but should for a \fBString\fP as well. 
.RE
.PP

.PP
Definition at line 460 of file ReferenceCountedArray.h.
.SS "\fBString\fP String::printf (const char * format,  ...)\fC [virtual]\fP"
.PP
Definition at line 203 of file String.cpp.
.SS "size_t \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::rcount () const\fC [inline, inherited]\fP"
.PP
Definition at line 363 of file ReferenceCountedArray.h.
.SS "\fBvalue_type\fP \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::read (int i) const\fC [inline, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBat()\fP Unlinke \fBat()\fP this is unchecked. 
.RE
.PP

.PP
Definition at line 449 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::replace (int k, const \fBReferenceCountedArray\fP< \fBString_Array_Type\fP > & rca, int n = \fC-1\fP)\fC [inline, inherited]\fP"
.PP
Replaces n elements in our buffer at index k with the given \fBReferenceCountedArray\fP object. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to replace at. 
.br
\fIrca\fP The \fBReferenceCountedArray\fP object to replace with. 
.br
\fIn\fP The number of characters to use for the replace. 
.RE
.PP

.PP
Definition at line 639 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::replace (int k, \fBconst_reference\fP item)\fC [inline, inherited]\fP"
.PP
Replace the given index with the given item. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to replace. 
.br
\fIitem\fP The item to replace with. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The given index has been replaced. 
.PP
COW is done if needed. 
.RE
.PP

.PP
Definition at line 626 of file ReferenceCountedArray.h.
.SS "void String::replace (int k, const char * string, int n = \fC-1\fP)"
.PP
Replaces the given index with the given cstring up to the given amount of characters. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to replace at. 
.br
\fIstring\fP The cstring to replace with. 
.br
\fIn\fP How many characters to use from string. 
.RE
.PP

.PP
Definition at line 96 of file String.cpp.
.SS "virtual void \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::Reserve (const size_t newSize) const\fC [inline, virtual, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBArrayRef::Reserve()\fP 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The \fBString\fP will also never shrink after this. 
.RE
.PP

.PP
Definition at line 374 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::setLength (size_t newLen) const\fC [inline, protected, inherited]\fP"
.PP
Set the lengths to the specified length. 
.PP
\fBParameters:\fP
.RS 4
\fInewLen\fP the new length to set to 
.RE
.PP

.PP
Definition at line 202 of file ReferenceCountedArray.h.
.SS "size_t \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::size () const\fC [inline, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBlength()\fP 
.RE
.PP

.PP
Definition at line 397 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::slice (int start, int len)\fC [inline, inherited]\fP"
.PP
Return a new array from a subarray. 
.PP
\fBReturns:\fP
.RS 4
a new \fBReferenceCountedArray\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIstart\fP The offset to begin the subarray from (indexed from 0) 
.br
\fIlen\fP The length of the subarray to return The returned slice is a reference to the original array until modified. 
.RE
.PP

.PP
Definition at line 529 of file ReferenceCountedArray.h.
.SS "\fBArray\fP< \fBString\fP > String::split (const \fBString\fP & delim, size_t limit = \fC\fBnpos\fP\fP) const"
.PP
Definition at line 152 of file String.cpp.
.SS "void \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::subLength (size_t diff) const\fC [inline, protected, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBsetLength()\fP 
.RE
.PP

.PP
Definition at line 212 of file ReferenceCountedArray.h.
.SS "\fBString\fP String::substring (int start, int len) const\fC [inline]\fP"
.PP
Definition at line 183 of file String.h.
.SS "\fBString\fP String::trim () const\fC [inline]\fP"
.PP
Trim off whitespace. 
.PP
\fBReturns:\fP
.RS 4
New string 
.RE
.PP

.PP
Definition at line 175 of file String.h.
.SS "\fBString\fP & String::trim ()"
.PP
Trim off whitespace. 
.PP
\fBReturns:\fP
.RS 4
The string, to allow for chaining 
.RE
.PP

.PP
Definition at line 220 of file String.cpp.
.SS "void \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::write (int i, \fBvalue_type\fP item)\fC [inline, inherited]\fP"
.PP
Definition at line 451 of file ReferenceCountedArray.h.
.SH "Friends And Related Function Documentation"
.PP 
.SS "bool operator!= (const \fBString\fP & lhs, const \fBString\fP & rhs)\fC [friend]\fP"
.PP
Definition at line 387 of file String.h.
.SS "\fBString\fP operator+ (const \fBString\fP & string1, const \fBString\fP & string2)\fC [friend]\fP"
.PP
Concatenates two string objects together. 
.PP
\fBParameters:\fP
.RS 4
\fIstring1\fP The LHS string. 
.br
\fIstring2\fP The RHS string. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A new string is allocated, reference copied and returned. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns a new string that can be reference copied by the lvalue. 
.RE
.PP

.PP
Definition at line 299 of file String.h.
.SS "bool operator< (const \fBString\fP & lhs, const \fBString\fP & rhs)\fC [friend]\fP"
.PP
Definition at line 391 of file String.h.
.SS "std::ostream& operator<< (std::ostream & os, const \fBString\fP & string)\fC [friend]\fP"
.PP
Definition at line 439 of file String.h.
.SS "bool operator<= (const \fBString\fP & lhs, const \fBString\fP & rhs)\fC [friend]\fP"
.PP
Definition at line 395 of file String.h.
.SS "bool operator== (const \fBString\fP & lhs, const \fBString\fP & rhs)\fC [friend]\fP"
.PP
Definition at line 383 of file String.h.
.SS "bool operator> (const \fBString\fP & lhs, const \fBString\fP & rhs)\fC [friend]\fP"
.PP
Definition at line 399 of file String.h.
.SS "bool operator>= (const \fBString\fP & lhs, const \fBString\fP & rhs)\fC [friend]\fP"
.PP
Definition at line 403 of file String.h.
.SS "std::ostream& operator>> (std::ostream &, const \fBString\fP &)\fC [friend]\fP"
.PP
.SH "Member Data Documentation"
.PP 
.SS "BDLIB_NS_BEGIN const size_t \fBString::npos\fP = size_t(-1)\fC [static]\fP"
.PP
Definition at line 66 of file String.h.
.SS "size_t \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::\fBoffset\fP\fC [mutable, protected, inherited]\fP"
.PP
This is for subarrays: so we know where the subarray starts. 
.PP
Definition at line 238 of file ReferenceCountedArray.h.
.SS "size_t \fBReferenceCountedArray\fP< \fBString_Array_Type\fP  >::\fBsublen\fP\fC [mutable, protected, inherited]\fP"
.PP
This is for subarrays: so we know where the subarray ends. 
.PP
Definition at line 242 of file ReferenceCountedArray.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for BDLIB from the source code.
