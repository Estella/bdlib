.TH "Array" 3 "18 Dec 2009" "Version 1.0" "BDLIB" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Array \- Dynamic \fBArray\fP.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <Array.h>\fP
.PP
Inherits ReferenceCountedArray<T>.
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef const value_type * \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef const value_type & \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef ptrdiff_t \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef value_type * \fBpointer\fP"
.br
.ti -1c
.RI "typedef value_type & \fBreference\fP"
.br
.ti -1c
.RI "typedef size_t \fBsize_type\fP"
.br
.ti -1c
.RI "typedef T \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBappend\fP (const ReferenceCountedArray &rca, int n=-1)"
.br
.RI "\fIAppends given rca to the end of buffer. \fP"
.ti -1c
.RI "void \fBappend\fP (const_reference item)"
.br
.RI "\fIAppends one item to end of buffer. \fP"
.ti -1c
.RI "\fBArray\fP (const size_type newSize)"
.br
.RI "\fICreate an empty \fBArray\fP container with at least the specified elements in size. \fP"
.ti -1c
.RI "\fBArray\fP (const_pointer carray, size_t len)"
.br
.RI "\fICreate a \fBArray\fP from a given carray. \fP"
.ti -1c
.RI "\fBArray\fP (const_pointer carray)"
.br
.RI "\fICreate a \fBArray\fP from a given carray. \fP"
.ti -1c
.RI "\fBArray\fP (const \fBArray\fP< value_type > &array)"
.br
.ti -1c
.RI "value_type \fBat\fP (int i) const "
.br
.RI "\fIReturns the character at the given index. \fP"
.ti -1c
.RI "const_pointer \fBbegin\fP () const "
.br
.ti -1c
.RI "size_t \fBcapacity\fP () const "
.br
.RI "\fIReturns capacity of the \fBString\fP object. \fP"
.ti -1c
.RI "virtual void \fBclear\fP ()"
.br
.RI "\fIClear contents of \fBString\fP and set length to 0. \fP"
.ti -1c
.RI "const_pointer \fBdata\fP () const "
.br
.RI "\fIData accessor. \fP"
.ti -1c
.RI "const_pointer \fBend\fP () const "
.br
.ti -1c
.RI "bool \fBequals\fP (const \fBArray\fP &array, size_t n) const "
.br
.RI "\fICompare our \fBArray\fP object with another \fBArray\fP object, but only n elements. \fP"
.ti -1c
.RI "bool \fBequals\fP (const \fBArray\fP &array) const "
.br
.ti -1c
.RI "size_t \fBfind\fP (const_reference item) const "
.br
.ti -1c
.RI "virtual size_t \fBhash\fP () const "
.br
.ti -1c
.RI "bool \fBhasIndex\fP (int i) const "
.br
.RI "\fIChecks if the buffer has the given index or not. \fP"
.ti -1c
.RI "void \fBinsert\fP (int k, const_reference item)"
.br
.RI "\fIInsert an item at the given index. \fP"
.ti -1c
.RI "void \fBinsert\fP (int k, const ReferenceCountedArray &rca, int n=-1)"
.br
.RI "\fIInserts a ReferenceCountedArray object into our buffer. \fP"
.ti -1c
.RI "bool \fBisEmpty\fP () const "
.br
.RI "\fICheck whether the string is 'empty'. \fP"
.ti -1c
.RI "bool \fBisShared\fP () const "
.br
.ti -1c
.RI "\fBString\fP \fBjoin\fP (const \fBString\fP &delim) const "
.br
.ti -1c
.RI "size_t \fBlength\fP () const "
.br
.RI "\fIReturns length of the string. \fP"
.ti -1c
.RI "bool \fBoperator!\fP () const "
.br
.ti -1c
.RI "\fBSlice\fP< \fBArray\fP > \fBoperator()\fP (int start, int len)"
.br
.RI "\fIReturns a 'Slice' class for safe (cow) writing into the array. \fP"
.ti -1c
.RI "\fBArray\fP \fBoperator()\fP (int start, int len) const "
.br
.ti -1c
.RI "\fBCref\fP \fBoperator[]\fP (int i)"
.br
.RI "\fIReturns 'Cref' class for safe (cow) writing into \fBString\fP. \fP"
.ti -1c
.RI "value_type \fBoperator[]\fP (int i) const "
.br
.RI "\fISafe element access operator. \fP"
.ti -1c
.RI "value_type \fBpop\fP ()"
.br
.ti -1c
.RI "void \fBpush\fP (const value_type item)"
.br
.ti -1c
.RI "size_t \fBrcount\fP () const "
.br
.ti -1c
.RI "value_type \fBread\fP (int i) const "
.br
.ti -1c
.RI "void \fBreplace\fP (int k, const ReferenceCountedArray &rca, int n=-1)"
.br
.RI "\fIReplaces n elements in our buffer at index k with the given ReferenceCountedArray object. \fP"
.ti -1c
.RI "void \fBreplace\fP (int k, const_reference item)"
.br
.RI "\fIReplace the given index with the given item. \fP"
.ti -1c
.RI "virtual void \fBReserve\fP (const size_t newSize) const "
.br
.ti -1c
.RI "size_t \fBsize\fP () const "
.br
.ti -1c
.RI "void \fBslice\fP (int start, int len)"
.br
.RI "\fIReturn a new array from a subarray. \fP"
.ti -1c
.RI "\fBArray\fP \fBsubarray\fP (int start, int len) const "
.br
.ti -1c
.RI "void \fBwrite\fP (int i, value_type item)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBAboutToModify\fP (size_t n) const "
.br
.ti -1c
.RI "void \fBaddLength\fP (size_t diff) const "
.br
.ti -1c
.RI "pointer \fBBuf\fP (int i=0) const "
.br
.RI "\fIMutable Ref->buf+offset reference for use internally. \fP"
.ti -1c
.RI "const_pointer \fBconstBuf\fP (int i=0) const "
.br
.RI "\fIRef->buf reference for use internally. \fP"
.ti -1c
.RI "void \fBgetOwnCopy\fP () const "
.br
.ti -1c
.RI "void \fBsetLength\fP (size_t newLen) const "
.br
.RI "\fISet the lengths to the specified length. \fP"
.ti -1c
.RI "void \fBsubLength\fP (size_t diff) const "
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "size_t \fBoffset\fP"
.br
.ti -1c
.RI "size_t \fBsublen\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBArray\fP &lhs, const \fBArray\fP &rhs)"
.br
.ti -1c
.RI "\fBArray\fP< value_type > & \fBoperator<<\fP (\fBArray\fP< value_type > &array, const_reference item)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBArray\fP &lhs, const \fBArray\fP &rhs)"
.br
.ti -1c
.RI "\fBArray\fP< value_type > & \fBoperator>>\fP (\fBArray\fP< value_type > &array, reference item)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class T> class Array< T >"
Dynamic \fBArray\fP. 
.PP
Definition at line 44 of file Array.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class T > \fBArray\fP< T >::\fBArray\fP (const_pointer carray)\fC [inline]\fP"
.PP
Create a \fBArray\fP from a given carray. 
.PP
\fBParameters:\fP
.RS 4
\fIcarray\fP The null-terminated array to create the object from. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A ArrayBuf has been initialized. 
.PP
The buffer has been filled with the array. 
.RE
.PP
\fBTest\fP
.RS 4
\fBArray\fP test('Some array'); 
.RE
.PP

.PP
Definition at line 70 of file Array.h.
.SS "template<class T > \fBArray\fP< T >::\fBArray\fP (const_pointer carray, size_t len)\fC [inline]\fP"
.PP
Create a \fBArray\fP from a given carray. 
.PP
\fBParameters:\fP
.RS 4
\fIcarray\fP The null-terminated array to create the object from. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A ArrayBuf has been initialized. 
.PP
The buffer has been filled with the array. 
.RE
.PP
\fBTest\fP
.RS 4
\fBArray\fP test('Some array'); 
.RE
.PP

.PP
Definition at line 86 of file Array.h.
.SS "template<class T > \fBArray\fP< T >::\fBArray\fP (const size_type newSize)\fC [inline, explicit]\fP"
.PP
Create an empty \fBArray\fP container with at least the specified elements in size. 
.PP
\fBParameters:\fP
.RS 4
\fInewSize\fP Reserve at least this many buckets for this \fBArray\fP. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
This array's memory will also never be shrunk. 
.PP
A buffer has been created. 
.RE
.PP

.PP
Definition at line 98 of file Array.h.
.SH "Member Function Documentation"
.PP 
.SS "template<class T> void ReferenceCountedArray< T >::addLength (size_t diff) const\fC [inline, protected, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
setLength() 
.RE
.PP

.PP
Definition at line 207 of file ReferenceCountedArray.h.
.SS "template<class T> void ReferenceCountedArray< T >::append (const ReferenceCountedArray< T > & rca, int n = \fC-1\fP)\fC [inline, inherited]\fP"
.PP
Appends given rca to the end of buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIrca\fP The rca to be appended. 
.br
\fIn\fP How many characters to copy from the ReferenceCountedArray object. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer is allocated. This is the same as inserting the rca at the end of the buffer. 
.RE
.PP

.PP
Definition at line 570 of file ReferenceCountedArray.h.
.SS "template<class T> void ReferenceCountedArray< T >::append (const_reference item)\fC [inline, inherited]\fP"
.PP
Appends one item to end of buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIitem\fP The item to be appended. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer is allocated. 
.PP
The item is appended at the end of the buffer. This is the same as inserting the item at the end of the buffer. 
.RE
.PP

.PP
Definition at line 562 of file ReferenceCountedArray.h.
.SS "template<class T> value_type ReferenceCountedArray< T >::at (int i) const\fC [inline, inherited]\fP"
.PP
Returns the character at the given index. 
.PP
\fBReturns:\fP
.RS 4
The character at the given index. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Index to return. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
The index must exist. 
.RE
.PP
\fBSee also:\fP
.RS 4
operator[]() 
.RE
.PP
\fBTodo\fP
.RS 4
Perhaps this should throw an exception if out of range? 
.RE
.PP

.PP
Definition at line 520 of file ReferenceCountedArray.h.
.SS "template<class T> pointer ReferenceCountedArray< T >::Buf (int i = \fC0\fP) const\fC [inline, protected, inherited]\fP"
.PP
Mutable Ref->buf+offset reference for use internally. 
.PP
Mutable Ref->buf reference for use internally 
.PP
Definition at line 222 of file ReferenceCountedArray.h.
.SS "template<class T> size_t ReferenceCountedArray< T >::capacity () const\fC [inline, inherited]\fP"
.PP
Returns capacity of the \fBString\fP object. 
.PP
\fBReturns:\fP
.RS 4
Capacity of the \fBString\fP object. 
.RE
.PP

.PP
Definition at line 385 of file ReferenceCountedArray.h.
.SS "template<class T> const_pointer ReferenceCountedArray< T >::data () const\fC [inline, inherited]\fP"
.PP
Data accessor. 
.PP
\fBReturns:\fP
.RS 4
Pointer to array of characters (not necesarily null-terminated). 
.RE
.PP

.PP
Definition at line 415 of file ReferenceCountedArray.h.
.SS "template<class T > bool \fBArray\fP< T >::equals (const \fBArray\fP< T > & array, size_t n) const\fC [inline]\fP"
.PP
Compare our \fBArray\fP object with another \fBArray\fP object, but only n elements. 
.PP
\fBParameters:\fP
.RS 4
\fIarray\fP The \fBArray\fP object to equals to. 
.br
\fIn\fP The number of items to equals. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if the number of elements are the same, and they all are equal. 
.RE
.PP

.PP
Definition at line 160 of file Array.h.
.SS "template<class T> bool ReferenceCountedArray< T >::hasIndex (int i) const\fC [inline, inherited]\fP"
.PP
Checks if the buffer has the given index or not. 
.PP
\fBReturns:\fP
.RS 4
Boolean true/false as to whether or not index exists. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Index to check. 
.RE
.PP

.PP
Definition at line 438 of file ReferenceCountedArray.h.
.SS "template<class T> void ReferenceCountedArray< T >::insert (int k, const_reference item)\fC [inline, inherited]\fP"
.PP
Insert an item at the given index. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to insert at. 
.br
\fIitem\fP The item to be inserted. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A buffer is allocated. 
.PP
If the old buffer was too small, it is enlarged. 
.PP
The item is inserted at the given index. 
.RE
.PP

.PP
Definition at line 609 of file ReferenceCountedArray.h.
.SS "template<class T> void ReferenceCountedArray< T >::insert (int k, const ReferenceCountedArray< T > & rca, int n = \fC-1\fP)\fC [inline, inherited]\fP"
.PP
Inserts a ReferenceCountedArray object into our buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to insert at. 
.br
\fIrca\fP The rca to insert. 
.br
\fIn\fP The length to insert. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer contains n items from rca inserted at index k. 
.RE
.PP

.PP
Definition at line 580 of file ReferenceCountedArray.h.
.SS "template<class T> bool ReferenceCountedArray< T >::isEmpty () const\fC [inline, inherited]\fP"
.PP
Check whether the string is 'empty'. 
.PP
\fBReturns:\fP
.RS 4
True if empty, false if non-empty 
.RE
.PP

.PP
Definition at line 403 of file ReferenceCountedArray.h.
.SS "template<class T> bool ReferenceCountedArray< T >::isShared () const\fC [inline, inherited]\fP"
.PP
\fBReturns:\fP
.RS 4
True if this object is shared; false if not. 
.RE
.PP

.PP
Definition at line 367 of file ReferenceCountedArray.h.
.SS "template<class T> size_t ReferenceCountedArray< T >::length () const\fC [inline, inherited]\fP"
.PP
Returns length of the string. 
.PP
\fBReturns:\fP
.RS 4
Length of the string. 
.RE
.PP

.PP
Definition at line 393 of file ReferenceCountedArray.h.
.SS "template<class T> bool ReferenceCountedArray< T >::operator! () const\fC [inline, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
isEmpty() This is for: if (!string) Having if(string) conflicts with another operator 
.RE
.PP

.PP
Definition at line 409 of file ReferenceCountedArray.h.
.SS "template<class T > \fBSlice\fP<\fBArray\fP> \fBArray\fP< T >::operator() (int start, int len)\fC [inline]\fP"
.PP
Returns a 'Slice' class for safe (cow) writing into the array. 
.PP
\fBSee also:\fP
.RS 4
\fBSlice\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIstart\fP Starting position 
.br
\fIlen\fP How many items to use 
.RE
.PP

.PP
Definition at line 206 of file Array.h.
.SS "template<class T> \fBCref\fP ReferenceCountedArray< T >::operator[] (int i)\fC [inline, inherited]\fP"
.PP
Returns 'Cref' class for safe (cow) writing into \fBString\fP. 
.PP
\fBSee also:\fP
.RS 4
\fBCref\fP 
.RE
.PP

.PP
Definition at line 510 of file ReferenceCountedArray.h.
.SS "template<class T> value_type ReferenceCountedArray< T >::operator[] (int i) const\fC [inline, inherited]\fP"
.PP
Safe element access operator. 
.PP
\fBTodo\fP
.RS 4
This is only called on a (const) \fBString\fP, but should for a \fBString\fP as well. 
.RE
.PP

.PP
Definition at line 460 of file ReferenceCountedArray.h.
.SS "template<class T> value_type ReferenceCountedArray< T >::read (int i) const\fC [inline, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
at() Unlinke at() this is unchecked. 
.RE
.PP

.PP
Definition at line 449 of file ReferenceCountedArray.h.
.SS "template<class T> void ReferenceCountedArray< T >::replace (int k, const ReferenceCountedArray< T > & rca, int n = \fC-1\fP)\fC [inline, inherited]\fP"
.PP
Replaces n elements in our buffer at index k with the given ReferenceCountedArray object. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to replace at. 
.br
\fIrca\fP The ReferenceCountedArray object to replace with. 
.br
\fIn\fP The number of characters to use for the replace. 
.RE
.PP

.PP
Definition at line 639 of file ReferenceCountedArray.h.
.SS "template<class T> void ReferenceCountedArray< T >::replace (int k, const_reference item)\fC [inline, inherited]\fP"
.PP
Replace the given index with the given item. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to replace. 
.br
\fIitem\fP The item to replace with. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The given index has been replaced. 
.PP
COW is done if needed. 
.RE
.PP

.PP
Definition at line 626 of file ReferenceCountedArray.h.
.SS "template<class T> virtual void ReferenceCountedArray< T >::Reserve (const size_t newSize) const\fC [inline, virtual, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBArrayRef::Reserve()\fP 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The \fBString\fP will also never shrink after this. 
.RE
.PP

.PP
Definition at line 374 of file ReferenceCountedArray.h.
.SS "template<class T> void ReferenceCountedArray< T >::setLength (size_t newLen) const\fC [inline, protected, inherited]\fP"
.PP
Set the lengths to the specified length. 
.PP
\fBParameters:\fP
.RS 4
\fInewLen\fP the new length to set to 
.RE
.PP

.PP
Definition at line 202 of file ReferenceCountedArray.h.
.SS "template<class T> size_t ReferenceCountedArray< T >::size () const\fC [inline, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
length() 
.RE
.PP

.PP
Definition at line 397 of file ReferenceCountedArray.h.
.SS "template<class T> void ReferenceCountedArray< T >::slice (int start, int len)\fC [inline, inherited]\fP"
.PP
Return a new array from a subarray. 
.PP
\fBReturns:\fP
.RS 4
a new ReferenceCountedArray 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIstart\fP The offset to begin the subarray from (indexed from 0) 
.br
\fIlen\fP The length of the subarray to return The returned slice is a reference to the original array until modified. 
.RE
.PP

.PP
Definition at line 529 of file ReferenceCountedArray.h.
.SS "template<class T> void ReferenceCountedArray< T >::subLength (size_t diff) const\fC [inline, protected, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
setLength() 
.RE
.PP

.PP
Definition at line 212 of file ReferenceCountedArray.h.
.SH "Friends And Related Function Documentation"
.PP 
.SS "template<class T > \fBArray\fP<value_type>& operator<< (\fBArray\fP< value_type > & array, const_reference item)\fC [friend]\fP"
.PP
\fBSee also:\fP
.RS 4
push 
.RE
.PP

.PP
Definition at line 116 of file Array.h.
.SS "template<class T > \fBArray\fP<value_type>& operator>> (\fBArray\fP< value_type > & array, reference item)\fC [friend]\fP"
.PP
\fBSee also:\fP
.RS 4
pop 
.RE
.PP

.PP
Definition at line 136 of file Array.h.
.SH "Member Data Documentation"
.PP 
.SS "template<class T> size_t ReferenceCountedArray< T >::offset\fC [mutable, protected, inherited]\fP"
.PP
This is for subarrays: so we know where the subarray starts. 
.PP
Definition at line 238 of file ReferenceCountedArray.h.
.SS "template<class T> size_t ReferenceCountedArray< T >::sublen\fC [mutable, protected, inherited]\fP"
.PP
This is for subarrays: so we know where the subarray ends. 
.PP
Definition at line 242 of file ReferenceCountedArray.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for BDLIB from the source code.
