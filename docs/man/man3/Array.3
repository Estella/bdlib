.TH "Array" 3 "18 Dec 2009" "Version 1.0" "BDLIB" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Array \- Dynamic \fBArray\fP.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <Array.h>\fP
.PP
Inherits \fBReferenceCountedArray< T >\fP.
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef const \fBvalue_type\fP * \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef const \fBvalue_type\fP & \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef ptrdiff_t \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef \fBvalue_type\fP * \fBpointer\fP"
.br
.ti -1c
.RI "typedef \fBvalue_type\fP & \fBreference\fP"
.br
.ti -1c
.RI "typedef size_t \fBsize_type\fP"
.br
.ti -1c
.RI "typedef T \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBappend\fP (const \fBReferenceCountedArray\fP &rca, int n=-1)"
.br
.RI "\fIAppends given rca to the end of buffer. \fP"
.ti -1c
.RI "void \fBappend\fP (\fBconst_reference\fP item)"
.br
.RI "\fIAppends one item to end of buffer. \fP"
.ti -1c
.RI "\fBArray\fP (const \fBsize_type\fP newSize)"
.br
.RI "\fICreate an empty \fBArray\fP container with at least the specified elements in size. \fP"
.ti -1c
.RI "\fBArray\fP (\fBconst_pointer\fP carray, size_t len)"
.br
.RI "\fICreate a \fBArray\fP from a given carray. \fP"
.ti -1c
.RI "\fBArray\fP (\fBconst_pointer\fP carray)"
.br
.RI "\fICreate a \fBArray\fP from a given carray. \fP"
.ti -1c
.RI "\fBArray\fP (const \fBArray\fP< \fBvalue_type\fP > &array)"
.br
.ti -1c
.RI "\fBArray\fP ()"
.br
.ti -1c
.RI "\fBvalue_type\fP \fBat\fP (int i) const"
.br
.RI "\fIReturns the character at the given index. \fP"
.ti -1c
.RI "\fBconst_pointer\fP \fBbegin\fP () const"
.br
.ti -1c
.RI "size_t \fBcapacity\fP () const"
.br
.RI "\fIReturns capacity of the \fBString\fP object. \fP"
.ti -1c
.RI "virtual void \fBclear\fP ()"
.br
.RI "\fIClear contents of \fBString\fP and set length to 0. \fP"
.ti -1c
.RI "\fBconst_pointer\fP \fBdata\fP () const"
.br
.RI "\fIData accessor. \fP"
.ti -1c
.RI "\fBconst_pointer\fP \fBend\fP () const"
.br
.ti -1c
.RI "bool \fBequals\fP (const \fBArray\fP &array, size_t n) const "
.br
.RI "\fICompare our \fBArray\fP object with another \fBArray\fP object, but only n elements. \fP"
.ti -1c
.RI "bool \fBequals\fP (const \fBArray\fP &array) const "
.br
.ti -1c
.RI "size_t \fBfind\fP (\fBconst_reference\fP item) const"
.br
.ti -1c
.RI "virtual size_t \fBhash\fP () const "
.br
.ti -1c
.RI "bool \fBhasIndex\fP (int i) const"
.br
.RI "\fIChecks if the buffer has the given index or not. \fP"
.ti -1c
.RI "void \fBinsert\fP (int k, \fBconst_reference\fP item)"
.br
.RI "\fIInsert an item at the given index. \fP"
.ti -1c
.RI "void \fBinsert\fP (int k, const \fBReferenceCountedArray\fP &rca, int n=-1)"
.br
.RI "\fIInserts a \fBReferenceCountedArray\fP object into our buffer. \fP"
.ti -1c
.RI "bool \fBisEmpty\fP () const"
.br
.RI "\fICheck whether the string is 'empty'. \fP"
.ti -1c
.RI "bool \fBisShared\fP () const"
.br
.ti -1c
.RI "\fBString\fP \fBjoin\fP (const \fBString\fP &delim) const "
.br
.ti -1c
.RI "size_t \fBlength\fP () const"
.br
.RI "\fIReturns length of the string. \fP"
.ti -1c
.RI "bool \fBoperator!\fP () const"
.br
.ti -1c
.RI "\fBSlice\fP< \fBArray\fP > \fBoperator()\fP (int start, int len)"
.br
.RI "\fIReturns a 'Slice' class for safe (cow) writing into the array. \fP"
.ti -1c
.RI "\fBArray\fP \fBoperator()\fP (int start, int len) const "
.br
.ti -1c
.RI "Cref \fBoperator[]\fP (int i)"
.br
.RI "\fIReturns 'Cref' class for safe (cow) writing into \fBString\fP. \fP"
.ti -1c
.RI "\fBvalue_type\fP \fBoperator[]\fP (int i) const"
.br
.RI "\fISafe element access operator. \fP"
.ti -1c
.RI "\fBvalue_type\fP \fBpop\fP ()"
.br
.ti -1c
.RI "void \fBpush\fP (const \fBvalue_type\fP item)"
.br
.ti -1c
.RI "size_t \fBrcount\fP () const"
.br
.ti -1c
.RI "\fBvalue_type\fP \fBread\fP (int i) const"
.br
.ti -1c
.RI "void \fBreplace\fP (int k, const \fBReferenceCountedArray\fP &rca, int n=-1)"
.br
.RI "\fIReplaces n elements in our buffer at index k with the given \fBReferenceCountedArray\fP object. \fP"
.ti -1c
.RI "void \fBreplace\fP (int k, \fBconst_reference\fP item)"
.br
.RI "\fIReplace the given index with the given item. \fP"
.ti -1c
.RI "virtual void \fBReserve\fP (const size_t newSize) const"
.br
.ti -1c
.RI "size_t \fBsize\fP () const"
.br
.ti -1c
.RI "void \fBslice\fP (int start, int len)"
.br
.RI "\fIReturn a new array from a subarray. \fP"
.ti -1c
.RI "\fBArray\fP \fBsubarray\fP (int start, int len) const "
.br
.ti -1c
.RI "void \fBwrite\fP (int i, \fBvalue_type\fP item)"
.br
.ti -1c
.RI "virtual \fB~Array\fP ()"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBAboutToModify\fP (size_t n) const"
.br
.ti -1c
.RI "void \fBaddLength\fP (size_t diff) const"
.br
.ti -1c
.RI "\fBpointer\fP \fBBuf\fP (int i=0) const"
.br
.RI "\fIMutable Ref->buf+offset reference for use internally. \fP"
.ti -1c
.RI "\fBconst_pointer\fP \fBconstBuf\fP (int i=0) const"
.br
.RI "\fIRef->buf reference for use internally. \fP"
.ti -1c
.RI "void \fBgetOwnCopy\fP () const"
.br
.ti -1c
.RI "void \fBsetLength\fP (size_t newLen) const"
.br
.RI "\fISet the lengths to the specified length. \fP"
.ti -1c
.RI "void \fBsubLength\fP (size_t diff) const"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "size_t \fBoffset\fP"
.br
.ti -1c
.RI "size_t \fBsublen\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBArray\fP &lhs, const \fBArray\fP &rhs)"
.br
.ti -1c
.RI "\fBArray\fP< \fBvalue_type\fP > & \fBoperator<<\fP (\fBArray\fP< \fBvalue_type\fP > &array, \fBconst_reference\fP item)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBArray\fP &lhs, const \fBArray\fP &rhs)"
.br
.ti -1c
.RI "\fBArray\fP< \fBvalue_type\fP > & \fBoperator>>\fP (\fBArray\fP< \fBvalue_type\fP > &array, \fBreference\fP item)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class T> class Array< T >"
Dynamic \fBArray\fP. 
.PP
Definition at line 44 of file Array.h.
.SH "Member Typedef Documentation"
.PP 
.SS "template<class T > typedef const \fBvalue_type\fP* \fBArray\fP< T >::\fBconst_pointer\fP"
.PP
Reimplemented from \fBReferenceCountedArray< T >\fP.
.PP
Definition at line 56 of file Array.h.
.SS "template<class T > typedef const \fBvalue_type\fP& \fBArray\fP< T >::\fBconst_reference\fP"
.PP
Reimplemented from \fBReferenceCountedArray< T >\fP.
.PP
Definition at line 58 of file Array.h.
.SS "template<class T > typedef ptrdiff_t \fBArray\fP< T >::\fBdifference_type\fP"
.PP
Reimplemented from \fBReferenceCountedArray< T >\fP.
.PP
Definition at line 54 of file Array.h.
.SS "template<class T > typedef \fBvalue_type\fP* \fBArray\fP< T >::\fBpointer\fP"
.PP
Reimplemented from \fBReferenceCountedArray< T >\fP.
.PP
Definition at line 55 of file Array.h.
.SS "template<class T > typedef \fBvalue_type\fP& \fBArray\fP< T >::\fBreference\fP"
.PP
Reimplemented from \fBReferenceCountedArray< T >\fP.
.PP
Definition at line 57 of file Array.h.
.SS "template<class T > typedef size_t \fBArray\fP< T >::\fBsize_type\fP"
.PP
Reimplemented from \fBReferenceCountedArray< T >\fP.
.PP
Definition at line 53 of file Array.h.
.SS "template<class T > typedef T \fBArray\fP< T >::\fBvalue_type\fP"
.PP
Reimplemented from \fBReferenceCountedArray< T >\fP.
.PP
Definition at line 51 of file Array.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class T > \fBArray\fP< T >::\fBArray\fP ()\fC [inline]\fP"
.PP
Definition at line 61 of file Array.h.
.SS "template<class T > \fBArray\fP< T >::\fBArray\fP (const \fBArray\fP< \fBvalue_type\fP > & array)\fC [inline]\fP"
.PP
Definition at line 62 of file Array.h.
.SS "template<class T > \fBArray\fP< T >::\fBArray\fP (\fBconst_pointer\fP carray)\fC [inline]\fP"
.PP
Create a \fBArray\fP from a given carray. 
.PP
\fBParameters:\fP
.RS 4
\fIcarray\fP The null-terminated array to create the object from. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A ArrayBuf has been initialized. 
.PP
The buffer has been filled with the array. 
.RE
.PP
\fBTest\fP
.RS 4
\fBArray\fP test('Some array'); 
.RE
.PP

.PP
Definition at line 70 of file Array.h.
.SS "template<class T > \fBArray\fP< T >::\fBArray\fP (\fBconst_pointer\fP carray, size_t len)\fC [inline]\fP"
.PP
Create a \fBArray\fP from a given carray. 
.PP
\fBParameters:\fP
.RS 4
\fIcarray\fP The null-terminated array to create the object from. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A ArrayBuf has been initialized. 
.PP
The buffer has been filled with the array. 
.RE
.PP
\fBTest\fP
.RS 4
\fBArray\fP test('Some array'); 
.RE
.PP

.PP
Definition at line 86 of file Array.h.
.SS "template<class T > \fBArray\fP< T >::\fBArray\fP (const \fBsize_type\fP newSize)\fC [inline, explicit]\fP"
.PP
Create an empty \fBArray\fP container with at least the specified elements in size. 
.PP
\fBParameters:\fP
.RS 4
\fInewSize\fP Reserve at least this many buckets for this \fBArray\fP. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
This array's memory will also never be shrunk. 
.PP
A buffer has been created. 
.RE
.PP

.PP
Definition at line 98 of file Array.h.
.SS "template<class T > virtual \fBArray\fP< T >::~\fBArray\fP ()\fC [inline, virtual]\fP"
.PP
Definition at line 100 of file Array.h.
.SH "Member Function Documentation"
.PP 
.SS "void \fBReferenceCountedArray\fP< T  >::AboutToModify (size_t n) const\fC [inline, protected, inherited]\fP"
.PP
Definition at line 297 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< T  >::addLength (size_t diff) const\fC [inline, protected, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBsetLength()\fP 
.RE
.PP

.PP
Definition at line 207 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< T  >::append (const \fBReferenceCountedArray\fP< T > & rca, int n = \fC-1\fP)\fC [inline, inherited]\fP"
.PP
Appends given rca to the end of buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIrca\fP The rca to be appended. 
.br
\fIn\fP How many characters to copy from the \fBReferenceCountedArray\fP object. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer is allocated. This is the same as inserting the rca at the end of the buffer. 
.RE
.PP

.PP
Definition at line 570 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< T  >::append (\fBconst_reference\fP item)\fC [inline, inherited]\fP"
.PP
Appends one item to end of buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIitem\fP The item to be appended. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer is allocated. 
.PP
The item is appended at the end of the buffer. This is the same as inserting the item at the end of the buffer. 
.RE
.PP

.PP
Definition at line 562 of file ReferenceCountedArray.h.
.SS "\fBvalue_type\fP \fBReferenceCountedArray\fP< T  >::at (int i) const\fC [inline, inherited]\fP"
.PP
Returns the character at the given index. 
.PP
\fBReturns:\fP
.RS 4
The character at the given index. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Index to return. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
The index must exist. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator[]()\fP 
.RE
.PP
\fBTodo\fP
.RS 4
Perhaps this should throw an exception if out of range? 
.RE
.PP

.PP
Definition at line 520 of file ReferenceCountedArray.h.
.SS "\fBconst_pointer\fP \fBReferenceCountedArray\fP< T  >::begin () const\fC [inline, inherited]\fP"
.PP
Definition at line 416 of file ReferenceCountedArray.h.
.SS "\fBpointer\fP \fBReferenceCountedArray\fP< T  >::Buf (int i = \fC0\fP) const\fC [inline, protected, inherited]\fP"
.PP
Mutable Ref->buf+offset reference for use internally. 
.PP
Mutable Ref->buf reference for use internally 
.PP
Definition at line 222 of file ReferenceCountedArray.h.
.SS "size_t \fBReferenceCountedArray\fP< T  >::capacity () const\fC [inline, inherited]\fP"
.PP
Returns capacity of the \fBString\fP object. 
.PP
\fBReturns:\fP
.RS 4
Capacity of the \fBString\fP object. 
.RE
.PP

.PP
Definition at line 385 of file ReferenceCountedArray.h.
.SS "virtual void \fBReferenceCountedArray\fP< T  >::clear ()\fC [inline, virtual, inherited]\fP"
.PP
Clear contents of \fBString\fP and set length to 0. 
.PP
Definition at line 379 of file ReferenceCountedArray.h.
.SS "\fBconst_pointer\fP \fBReferenceCountedArray\fP< T  >::constBuf (int i = \fC0\fP) const\fC [inline, protected, inherited]\fP"
.PP
Ref->buf reference for use internally. 
.PP
Definition at line 227 of file ReferenceCountedArray.h.
.SS "\fBconst_pointer\fP \fBReferenceCountedArray\fP< T  >::data () const\fC [inline, inherited]\fP"
.PP
Data accessor. 
.PP
\fBReturns:\fP
.RS 4
Pointer to array of characters (not necesarily null-terminated). 
.RE
.PP

.PP
Definition at line 415 of file ReferenceCountedArray.h.
.SS "\fBconst_pointer\fP \fBReferenceCountedArray\fP< T  >::end () const\fC [inline, inherited]\fP"
.PP
Definition at line 417 of file ReferenceCountedArray.h.
.SS "template<class T > bool \fBArray\fP< T >::equals (const \fBArray\fP< T > & array, size_t n) const\fC [inline]\fP"
.PP
Compare our \fBArray\fP object with another \fBArray\fP object, but only n elements. 
.PP
\fBParameters:\fP
.RS 4
\fIarray\fP The \fBArray\fP object to equals to. 
.br
\fIn\fP The number of items to equals. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if the number of elements are the same, and they all are equal. 
.RE
.PP

.PP
Definition at line 160 of file Array.h.
.SS "template<class T > bool \fBArray\fP< T >::equals (const \fBArray\fP< T > & array) const\fC [inline]\fP"
.PP
Definition at line 153 of file Array.h.
.SS "size_t \fBReferenceCountedArray\fP< T  >::find (\fBconst_reference\fP item) const\fC [inline, inherited]\fP"
.PP
Definition at line 425 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< T  >::getOwnCopy () const\fC [inline, protected, inherited]\fP"
.PP
Definition at line 296 of file ReferenceCountedArray.h.
.SS "template<class T > virtual size_t \fBArray\fP< T >::hash () const\fC [inline, virtual]\fP"
.PP
Implements \fBReferenceCountedArray< T >\fP.
.PP
Definition at line 102 of file Array.h.
.SS "bool \fBReferenceCountedArray\fP< T  >::hasIndex (int i) const\fC [inline, inherited]\fP"
.PP
Checks if the buffer has the given index or not. 
.PP
\fBReturns:\fP
.RS 4
Boolean true/false as to whether or not index exists. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Index to check. 
.RE
.PP

.PP
Definition at line 438 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< T  >::insert (int k, \fBconst_reference\fP item)\fC [inline, inherited]\fP"
.PP
Insert an item at the given index. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to insert at. 
.br
\fIitem\fP The item to be inserted. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
A buffer is allocated. 
.PP
If the old buffer was too small, it is enlarged. 
.PP
The item is inserted at the given index. 
.RE
.PP

.PP
Definition at line 609 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< T  >::insert (int k, const \fBReferenceCountedArray\fP< T > & rca, int n = \fC-1\fP)\fC [inline, inherited]\fP"
.PP
Inserts a \fBReferenceCountedArray\fP object into our buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to insert at. 
.br
\fIrca\fP The rca to insert. 
.br
\fIn\fP The length to insert. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The buffer contains n items from rca inserted at index k. 
.RE
.PP

.PP
Definition at line 580 of file ReferenceCountedArray.h.
.SS "bool \fBReferenceCountedArray\fP< T  >::isEmpty () const\fC [inline, inherited]\fP"
.PP
Check whether the string is 'empty'. 
.PP
\fBReturns:\fP
.RS 4
True if empty, false if non-empty 
.RE
.PP

.PP
Definition at line 403 of file ReferenceCountedArray.h.
.SS "bool \fBReferenceCountedArray\fP< T  >::isShared () const\fC [inline, inherited]\fP"
.PP
\fBReturns:\fP
.RS 4
True if this object is shared; false if not. 
.RE
.PP

.PP
Definition at line 367 of file ReferenceCountedArray.h.
.SS "template<class T > \fBString\fP \fBArray\fP< T >::join (const \fBString\fP & delim) const\fC [inline]\fP"
.PP
Definition at line 144 of file Array.h.
.SS "size_t \fBReferenceCountedArray\fP< T  >::length () const\fC [inline, inherited]\fP"
.PP
Returns length of the string. 
.PP
\fBReturns:\fP
.RS 4
Length of the string. 
.RE
.PP

.PP
Definition at line 393 of file ReferenceCountedArray.h.
.SS "bool \fBReferenceCountedArray\fP< T  >::operator! () const\fC [inline, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBisEmpty()\fP This is for: if (!string) Having if(string) conflicts with another operator 
.RE
.PP

.PP
Definition at line 409 of file ReferenceCountedArray.h.
.SS "template<class T > \fBSlice\fP<\fBArray\fP> \fBArray\fP< T >::operator() (int start, int len)\fC [inline]\fP"
.PP
Returns a 'Slice' class for safe (cow) writing into the array. 
.PP
\fBSee also:\fP
.RS 4
\fBSlice\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIstart\fP Starting position 
.br
\fIlen\fP How many items to use 
.RE
.PP

.PP
Definition at line 206 of file Array.h.
.SS "template<class T > \fBArray\fP \fBArray\fP< T >::operator() (int start, int len) const\fC [inline]\fP"
.PP
Definition at line 198 of file Array.h.
.SS "Cref \fBReferenceCountedArray\fP< T  >::operator[] (int i)\fC [inline, inherited]\fP"
.PP
Returns 'Cref' class for safe (cow) writing into \fBString\fP. 
.PP
\fBSee also:\fP
.RS 4
Cref 
.RE
.PP

.PP
Definition at line 510 of file ReferenceCountedArray.h.
.SS "\fBvalue_type\fP \fBReferenceCountedArray\fP< T  >::operator[] (int i) const\fC [inline, inherited]\fP"
.PP
Safe element access operator. 
.PP
\fBTodo\fP
.RS 4
This is only called on a (const) \fBString\fP, but should for a \fBString\fP as well. 
.RE
.PP

.PP
Definition at line 460 of file ReferenceCountedArray.h.
.SS "template<class T > \fBvalue_type\fP \fBArray\fP< T >::pop ()\fC [inline]\fP"
.PP
Definition at line 125 of file Array.h.
.SS "template<class T > void \fBArray\fP< T >::push (const \fBvalue_type\fP item)\fC [inline]\fP"
.PP
Definition at line 107 of file Array.h.
.SS "size_t \fBReferenceCountedArray\fP< T  >::rcount () const\fC [inline, inherited]\fP"
.PP
Definition at line 363 of file ReferenceCountedArray.h.
.SS "\fBvalue_type\fP \fBReferenceCountedArray\fP< T  >::read (int i) const\fC [inline, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBat()\fP Unlinke \fBat()\fP this is unchecked. 
.RE
.PP

.PP
Definition at line 449 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< T  >::replace (int k, const \fBReferenceCountedArray\fP< T > & rca, int n = \fC-1\fP)\fC [inline, inherited]\fP"
.PP
Replaces n elements in our buffer at index k with the given \fBReferenceCountedArray\fP object. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to replace at. 
.br
\fIrca\fP The \fBReferenceCountedArray\fP object to replace with. 
.br
\fIn\fP The number of characters to use for the replace. 
.RE
.PP

.PP
Definition at line 639 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< T  >::replace (int k, \fBconst_reference\fP item)\fC [inline, inherited]\fP"
.PP
Replace the given index with the given item. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP The index to replace. 
.br
\fIitem\fP The item to replace with. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The given index has been replaced. 
.PP
COW is done if needed. 
.RE
.PP

.PP
Definition at line 626 of file ReferenceCountedArray.h.
.SS "virtual void \fBReferenceCountedArray\fP< T  >::Reserve (const size_t newSize) const\fC [inline, virtual, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBArrayRef::Reserve()\fP 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The \fBString\fP will also never shrink after this. 
.RE
.PP

.PP
Definition at line 374 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< T  >::setLength (size_t newLen) const\fC [inline, protected, inherited]\fP"
.PP
Set the lengths to the specified length. 
.PP
\fBParameters:\fP
.RS 4
\fInewLen\fP the new length to set to 
.RE
.PP

.PP
Definition at line 202 of file ReferenceCountedArray.h.
.SS "size_t \fBReferenceCountedArray\fP< T  >::size () const\fC [inline, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBlength()\fP 
.RE
.PP

.PP
Definition at line 397 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< T  >::slice (int start, int len)\fC [inline, inherited]\fP"
.PP
Return a new array from a subarray. 
.PP
\fBReturns:\fP
.RS 4
a new \fBReferenceCountedArray\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIstart\fP The offset to begin the subarray from (indexed from 0) 
.br
\fIlen\fP The length of the subarray to return The returned slice is a reference to the original array until modified. 
.RE
.PP

.PP
Definition at line 529 of file ReferenceCountedArray.h.
.SS "template<class T > \fBArray\fP \fBArray\fP< T >::subarray (int start, int len) const\fC [inline]\fP"
.PP
Definition at line 189 of file Array.h.
.SS "void \fBReferenceCountedArray\fP< T  >::subLength (size_t diff) const\fC [inline, protected, inherited]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBsetLength()\fP 
.RE
.PP

.PP
Definition at line 212 of file ReferenceCountedArray.h.
.SS "void \fBReferenceCountedArray\fP< T  >::write (int i, \fBvalue_type\fP item)\fC [inline, inherited]\fP"
.PP
Definition at line 451 of file ReferenceCountedArray.h.
.SH "Friends And Related Function Documentation"
.PP 
.SS "template<class T > bool operator!= (const \fBArray\fP< T > & lhs, const \fBArray\fP< T > & rhs)\fC [friend]\fP"
.PP
Definition at line 183 of file Array.h.
.SS "template<class T > \fBArray\fP<\fBvalue_type\fP>& operator<< (\fBArray\fP< \fBvalue_type\fP > & array, \fBconst_reference\fP item)\fC [friend]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBpush\fP 
.RE
.PP

.PP
Definition at line 116 of file Array.h.
.SS "template<class T > bool operator== (const \fBArray\fP< T > & lhs, const \fBArray\fP< T > & rhs)\fC [friend]\fP"
.PP
Definition at line 182 of file Array.h.
.SS "template<class T > \fBArray\fP<\fBvalue_type\fP>& operator>> (\fBArray\fP< \fBvalue_type\fP > & array, \fBreference\fP item)\fC [friend]\fP"
.PP
\fBSee also:\fP
.RS 4
\fBpop\fP 
.RE
.PP

.PP
Definition at line 136 of file Array.h.
.SH "Member Data Documentation"
.PP 
.SS "size_t \fBReferenceCountedArray\fP< T  >::\fBoffset\fP\fC [mutable, protected, inherited]\fP"
.PP
This is for subarrays: so we know where the subarray starts. 
.PP
Definition at line 238 of file ReferenceCountedArray.h.
.SS "size_t \fBReferenceCountedArray\fP< T  >::\fBsublen\fP\fC [mutable, protected, inherited]\fP"
.PP
This is for subarrays: so we know where the subarray ends. 
.PP
Definition at line 242 of file ReferenceCountedArray.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for BDLIB from the source code.
