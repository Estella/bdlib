.TH "todo" 3 "18 Dec 2009" "Version 1.0" "BDLIB" \" -*- nroff -*-
.ad l
.nh
.SH NAME
todo \- Todo \fBList\fP 
 
.IP "\fBClass \fBHashTable< Key, Value >\fP \fP" 1c
replace() 
.PP
iterators 
.PP
resizing/growing
.PP
.PP
.PP
 
.IP "\fBMember \fBStack::peek\fP() const  \fP" 1c
Throw an exception? 
.PP
.PP
 
.IP "\fBClass \fBString\fP \fP" 1c
compute hash on insert, then use to compare instead of strcmp 
.PP
an updating hash as the copy is done. 
.PP
.PP
 
.IP "\fBMember \fBString::charAt\fP(int i) const  \fP" 1c
Perhaps this should throw an exception if out of range? 
.PP
.PP
 
.IP "\fBMember \fBString::operator[]\fP(int i) const  \fP" 1c
This is only called on a (const) \fBString\fP, but should for a \fBString\fP as well. 
.PP
.PP
 
.IP "\fBClass \fBStringBuf\fP \fP" 1c
look into something like a string object made of string pointers, and << displays all of the pointed to objects. (this would save copying to construct immuatable concatenated strings, but would only work with the << stream 
.PP
.PP
 
.IP "\fBMember \fBStringBuf::AllocBuf\fP(const size_t bytes) const  \fP" 1c
Implement mempool here. 
.PP
.PP
 
.IP "\fBMember \fBStringBuf::FreeBuf\fP(const char *p) const  \fP" 1c
Implement mempool here. 
.PP

